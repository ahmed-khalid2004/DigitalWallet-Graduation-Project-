===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\.vs\DigitalWallet\v17\DocumentLayout.backup.json =====
{
  "Version": 1,
  "WorkspaceRootPath": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\",
  "Documents": [
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\controllers\\admincontroller.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\controllers\\admincontroller.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\digitalwallet.api.csproj||{FA3CD31E-987B-443A-9B81-186104E8DAC1}|",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\digitalwallet.api.csproj||{FA3CD31E-987B-443A-9B81-186104E8DAC1}|"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Program Files\\dotnet\\sdk\\9.0.308\\Sdks\\Microsoft.NET.Sdk.Razor\\targets\\Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets||{FA3CD31E-987B-443A-9B81-186104E8DAC1}|"
    },
    {
      "AbsoluteMoniker": "D:0:0:{F2DF1F12-150B-4E32-8FEE-78BE898F168C}|DigitalWallet.Domain\\DigitalWallet.Domain.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.domain\\entities\\user.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{F2DF1F12-150B-4E32-8FEE-78BE898F168C}|DigitalWallet.Domain\\DigitalWallet.Domain.csproj|solutionrelative:digitalwallet.domain\\entities\\user.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\appsettings.development.json||{90A6B3A7-C1A3-4009-A288-E2FF89E96FA0}",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\appsettings.development.json||{90A6B3A7-C1A3-4009-A288-E2FF89E96FA0}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\appsettings.json||{90A6B3A7-C1A3-4009-A288-E2FF89E96FA0}",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\appsettings.json||{90A6B3A7-C1A3-4009-A288-E2FF89E96FA0}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\program.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\program.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    }
  ],
  "DocumentGroupContainers": [
    {
      "Orientation": 0,
      "VerticalTabListWidth": 256,
      "DocumentGroups": [
        {
          "DockedWidth": 200,
          "SelectedChildIndex": 3,
          "Children": [
            {
              "$type": "Bookmark",
              "Name": "ST:128:0:{1fc202d4-d401-403c-9834-5b218574bb67}"
            },
            {
              "$type": "Bookmark",
              "Name": "ST:0:0:{1c4feeaa-4718-4aa9-859d-94ce25d182ba}"
            },
            {
              "$type": "Bookmark",
              "Name": "ST:128:0:{116d2292-e37d-41cd-a077-ebacac4c8cc4}"
            },
            {
              "$type": "Document",
              "DocumentIndex": 0,
              "Title": "AdminController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AdminController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\AdminController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AdminController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\AdminController.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAABIAAAAjAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-05T20:40:57.993Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 1,
              "Title": "DigitalWallet.API.csproj",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\DigitalWallet.API.csproj",
              "RelativeDocumentMoniker": "DigitalWallet.API\\DigitalWallet.API.csproj",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\DigitalWallet.API.csproj",
              "RelativeToolTip": "DigitalWallet.API\\DigitalWallet.API.csproj",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAACYAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000758|",
              "WhenOpened": "2026-02-02T23:17:12.977Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 2,
              "Title": "Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets",
              "DocumentMoniker": "C:\\Program Files\\dotnet\\sdk\\9.0.308\\Sdks\\Microsoft.NET.Sdk.Razor\\targets\\Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets",
              "RelativeDocumentMoniker": "..\\..\\..\\..\\Program Files\\dotnet\\sdk\\9.0.308\\Sdks\\Microsoft.NET.Sdk.Razor\\targets\\Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets",
              "ToolTip": "C:\\Program Files\\dotnet\\sdk\\9.0.308\\Sdks\\Microsoft.NET.Sdk.Razor\\targets\\Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets",
              "RelativeToolTip": "..\\..\\..\\..\\Program Files\\dotnet\\sdk\\9.0.308\\Sdks\\Microsoft.NET.Sdk.Razor\\targets\\Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets",
              "ViewState": "AgIAACgAAAAAAAAAAAAlwDUAAAAEAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.003801|",
              "WhenOpened": "2026-02-02T23:52:48.99Z"
            },
            {
              "$type": "Document",
              "DocumentIndex": 3,
              "Title": "User.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.Domain\\Entities\\User.cs",
              "RelativeDocumentMoniker": "DigitalWallet.Domain\\Entities\\User.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.Domain\\Entities\\User.cs",
              "RelativeToolTip": "DigitalWallet.Domain\\Entities\\User.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:50:00.551Z"
            },
            {
              "$type": "Document",
              "DocumentIndex": 4,
              "Title": "appsettings.Development.json",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\appsettings.Development.json",
              "RelativeDocumentMoniker": "DigitalWallet.API\\appsettings.Development.json",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\appsettings.Development.json",
              "RelativeToolTip": "DigitalWallet.API\\appsettings.Development.json",
              "ViewState": "AgIAAA8AAAAAAAAAAAAcwBkAAAAEAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.001642|",
              "WhenOpened": "2026-02-02T23:19:37.513Z"
            },
            {
              "$type": "Document",
              "DocumentIndex": 5,
              "Title": "appsettings.json",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\appsettings.json",
              "RelativeDocumentMoniker": "DigitalWallet.API\\appsettings.json",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\appsettings.json",
              "RelativeToolTip": "DigitalWallet.API\\appsettings.json",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAAUAAAApAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.001642|",
              "WhenOpened": "2026-02-02T23:18:30.147Z"
            },
            {
              "$type": "Document",
              "DocumentIndex": 6,
              "Title": "Program.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Program.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Program.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Program.cs",
              "RelativeToolTip": "DigitalWallet.API\\Program.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAAkAAAA9AAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:17:52.059Z"
            }
          ]
        }
      ]
    }
  ]
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\.vs\DigitalWallet\v17\DocumentLayout.json =====
{
  "Version": 1,
  "WorkspaceRootPath": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\",
  "Documents": [
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\appsettings.json||{90A6B3A7-C1A3-4009-A288-E2FF89E96FA0}",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\appsettings.json||{90A6B3A7-C1A3-4009-A288-E2FF89E96FA0}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\controllers\\usercontroller.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\controllers\\usercontroller.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\controllers\\authcontroller.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\controllers\\authcontroller.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\controllers\\admincontroller.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\controllers\\admincontroller.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\digitalwallet.api.csproj||{FA3CD31E-987B-443A-9B81-186104E8DAC1}|",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\digitalwallet.api.csproj||{FA3CD31E-987B-443A-9B81-186104E8DAC1}|"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Program Files\\dotnet\\sdk\\9.0.308\\Sdks\\Microsoft.NET.Sdk.Razor\\targets\\Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets||{FA3CD31E-987B-443A-9B81-186104E8DAC1}|"
    },
    {
      "AbsoluteMoniker": "D:0:0:{F2DF1F12-150B-4E32-8FEE-78BE898F168C}|DigitalWallet.Domain\\DigitalWallet.Domain.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.domain\\entities\\user.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{F2DF1F12-150B-4E32-8FEE-78BE898F168C}|DigitalWallet.Domain\\DigitalWallet.Domain.csproj|solutionrelative:digitalwallet.domain\\entities\\user.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\appsettings.development.json||{90A6B3A7-C1A3-4009-A288-E2FF89E96FA0}",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\appsettings.development.json||{90A6B3A7-C1A3-4009-A288-E2FF89E96FA0}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|c:\\users\\softlaptop\\desktop\\digitalwallet-graduation-project-\\digitalwallet.api\\program.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{ACAA2DA1-0C5F-49B3-B49A-DE6EE5F1E17B}|DigitalWallet.API\\DigitalWallet.API.csproj|solutionrelative:digitalwallet.api\\program.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    }
  ],
  "DocumentGroupContainers": [
    {
      "Orientation": 0,
      "VerticalTabListWidth": 256,
      "DocumentGroups": [
        {
          "DockedWidth": 200,
          "SelectedChildIndex": 10,
          "Children": [
            {
              "$type": "Bookmark",
              "Name": "ST:128:0:{1fc202d4-d401-403c-9834-5b218574bb67}"
            },
            {
              "$type": "Bookmark",
              "Name": "ST:0:0:{1c4feeaa-4718-4aa9-859d-94ce25d182ba}"
            },
            {
              "$type": "Bookmark",
              "Name": "ST:128:0:{116d2292-e37d-41cd-a077-ebacac4c8cc4}"
            },
            {
              "$type": "Document",
              "DocumentIndex": 1,
              "Title": "UserController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\UserController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\UserController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\UserController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\UserController.cs",
              "ViewState": "AgIAAAkAAAAAAAAAAAAAAGEAAAA/AAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-05T21:49:10.27Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 2,
              "Title": "AuthController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AuthController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\AuthController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AuthController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\AuthController.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-05T21:31:49.441Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 3,
              "Title": "AdminController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AdminController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\AdminController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AdminController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\AdminController.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAACsAAAANAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-05T20:40:57.993Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 4,
              "Title": "DigitalWallet.API.csproj",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\DigitalWallet.API.csproj",
              "RelativeDocumentMoniker": "DigitalWallet.API\\DigitalWallet.API.csproj",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\DigitalWallet.API.csproj",
              "RelativeToolTip": "DigitalWallet.API\\DigitalWallet.API.csproj",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAACYAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000758|",
              "WhenOpened": "2026-02-02T23:17:12.977Z"
            },
            {
              "$type": "Document",
              "DocumentIndex": 5,
              "Title": "Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets",
              "DocumentMoniker": "C:\\Program Files\\dotnet\\sdk\\9.0.308\\Sdks\\Microsoft.NET.Sdk.Razor\\targets\\Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets",
              "RelativeDocumentMoniker": "..\\..\\..\\..\\Program Files\\dotnet\\sdk\\9.0.308\\Sdks\\Microsoft.NET.Sdk.Razor\\targets\\Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets",
              "ToolTip": "C:\\Program Files\\dotnet\\sdk\\9.0.308\\Sdks\\Microsoft.NET.Sdk.Razor\\targets\\Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets",
              "RelativeToolTip": "..\\..\\..\\..\\Program Files\\dotnet\\sdk\\9.0.308\\Sdks\\Microsoft.NET.Sdk.Razor\\targets\\Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets",
              "ViewState": "AgIAACgAAAAAAAAAAAAlwDUAAAAEAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.003801|",
              "WhenOpened": "2026-02-02T23:52:48.99Z"
            },
            {
              "$type": "Document",
              "DocumentIndex": 6,
              "Title": "User.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.Domain\\Entities\\User.cs",
              "RelativeDocumentMoniker": "DigitalWallet.Domain\\Entities\\User.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.Domain\\Entities\\User.cs",
              "RelativeToolTip": "DigitalWallet.Domain\\Entities\\User.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:50:00.551Z"
            },
            {
              "$type": "Document",
              "DocumentIndex": 7,
              "Title": "appsettings.Development.json",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\appsettings.Development.json",
              "RelativeDocumentMoniker": "DigitalWallet.API\\appsettings.Development.json",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\appsettings.Development.json",
              "RelativeToolTip": "DigitalWallet.API\\appsettings.Development.json",
              "ViewState": "AgIAAA8AAAAAAAAAAAAcwBkAAAAEAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.001642|",
              "WhenOpened": "2026-02-02T23:19:37.513Z"
            },
            {
              "$type": "Document",
              "DocumentIndex": 0,
              "Title": "appsettings.json",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\appsettings.json",
              "RelativeDocumentMoniker": "DigitalWallet.API\\appsettings.json",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\appsettings.json",
              "RelativeToolTip": "DigitalWallet.API\\appsettings.json",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAABAAAAAEAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.001642|",
              "WhenOpened": "2026-02-02T23:18:30.147Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 8,
              "Title": "Program.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Program.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Program.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Program.cs",
              "RelativeToolTip": "DigitalWallet.API\\Program.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAAkAAAA9AAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:17:52.059Z"
            }
          ]
        }
      ]
    }
  ]
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\.vs\DigitalWallet-Graduation-Project-\v17\DocumentLayout.json =====
{
  "Version": 1,
  "WorkspaceRootPath": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\",
  "Documents": [
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Middleware\\JwtMiddleware.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Middleware\\JwtMiddleware.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Middleware\\ExceptionHandlingMiddleware.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Middleware\\ExceptionHandlingMiddleware.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Middleware\\RequestLoggingMiddleware.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Middleware\\RequestLoggingMiddleware.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Filters\\ValidationFilter.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Filters\\ValidationFilter.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Filters\\AuthorizationFilter.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Filters\\AuthorizationFilter.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Extensions\\SwaggerExtensions.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Extensions\\SwaggerExtensions.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Extensions\\ServiceCollectionExtensions.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Extensions\\ServiceCollectionExtensions.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Extensions\\ApplicationBuilderExtensions.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Extensions\\ApplicationBuilderExtensions.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\WalletController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Controllers\\WalletController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\UserController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Controllers\\UserController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\TransferController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Controllers\\TransferController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\TransactionController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Controllers\\TransactionController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\NotificationController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Controllers\\NotificationController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\MoneyRequestController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Controllers\\MoneyRequestController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\FakeBankController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Controllers\\FakeBankController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\BillPaymentController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Controllers\\BillPaymentController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\BaseController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Controllers\\BaseController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AuthController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Controllers\\AuthController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AdminController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Controllers\\AdminController.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Program.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:DigitalWallet.API\\Program.cs||{A6C744A8-0E4A-4FC6-886A-064283054674}"
    }
  ],
  "DocumentGroupContainers": [
    {
      "Orientation": 0,
      "VerticalTabListWidth": 256,
      "DocumentGroups": [
        {
          "DockedWidth": 200,
          "SelectedChildIndex": 9,
          "Children": [
            {
              "$type": "Bookmark",
              "Name": "ST:128:0:{1fc202d4-d401-403c-9834-5b218574bb67}"
            },
            {
              "$type": "Bookmark",
              "Name": "ST:0:0:{1c4feeaa-4718-4aa9-859d-94ce25d182ba}"
            },
            {
              "$type": "Bookmark",
              "Name": "ST:128:0:{116d2292-e37d-41cd-a077-ebacac4c8cc4}"
            },
            {
              "$type": "Document",
              "DocumentIndex": 5,
              "Title": "SwaggerExtensions.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Extensions\\SwaggerExtensions.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Extensions\\SwaggerExtensions.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Extensions\\SwaggerExtensions.cs",
              "RelativeToolTip": "DigitalWallet.API\\Extensions\\SwaggerExtensions.cs",
              "ViewState": "AgIAAF8AAAAAAAAAAAAcwHYAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:13:08.217Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 6,
              "Title": "ServiceCollectionExtensions.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Extensions\\ServiceCollectionExtensions.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Extensions\\ServiceCollectionExtensions.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Extensions\\ServiceCollectionExtensions.cs",
              "RelativeToolTip": "DigitalWallet.API\\Extensions\\ServiceCollectionExtensions.cs",
              "ViewState": "AgIAAEcAAAAAAAAAAAAcwF4AAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:12:45.209Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 4,
              "Title": "AuthorizationFilter.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Filters\\AuthorizationFilter.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Filters\\AuthorizationFilter.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Filters\\AuthorizationFilter.cs",
              "RelativeToolTip": "DigitalWallet.API\\Filters\\AuthorizationFilter.cs",
              "ViewState": "AgIAAGEAAAAAAAAAAAAcwHgAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:12:15.247Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 3,
              "Title": "ValidationFilter.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Filters\\ValidationFilter.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Filters\\ValidationFilter.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Filters\\ValidationFilter.cs",
              "RelativeToolTip": "DigitalWallet.API\\Filters\\ValidationFilter.cs",
              "ViewState": "AgIAADwAAAAAAAAAAAAcwFMAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:12:06.462Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 1,
              "Title": "ExceptionHandlingMiddleware.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Middleware\\ExceptionHandlingMiddleware.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Middleware\\ExceptionHandlingMiddleware.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Middleware\\ExceptionHandlingMiddleware.cs",
              "RelativeToolTip": "DigitalWallet.API\\Middleware\\ExceptionHandlingMiddleware.cs",
              "ViewState": "AgIAAHoAAAAAAAAAAAAcwJEAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:11:02.904Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 2,
              "Title": "RequestLoggingMiddleware.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Middleware\\RequestLoggingMiddleware.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Middleware\\RequestLoggingMiddleware.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Middleware\\RequestLoggingMiddleware.cs",
              "RelativeToolTip": "DigitalWallet.API\\Middleware\\RequestLoggingMiddleware.cs",
              "ViewState": "AgIAAFAAAAAAAAAAAAAcwGcAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:11:31.831Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 0,
              "Title": "JwtMiddleware.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Middleware\\JwtMiddleware.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Middleware\\JwtMiddleware.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Middleware\\JwtMiddleware.cs",
              "RelativeToolTip": "DigitalWallet.API\\Middleware\\JwtMiddleware.cs",
              "ViewState": "AgIAAI4AAAAAAAAAAAAcwKUAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:11:45.671Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 7,
              "Title": "ApplicationBuilderExtensions.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Extensions\\ApplicationBuilderExtensions.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Extensions\\ApplicationBuilderExtensions.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Extensions\\ApplicationBuilderExtensions.cs",
              "RelativeToolTip": "DigitalWallet.API\\Extensions\\ApplicationBuilderExtensions.cs",
              "ViewState": "AgIAAC0AAAAAAAAAAAAcwEQAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:12:55.485Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 12,
              "Title": "NotificationController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\NotificationController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\NotificationController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\NotificationController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\NotificationController.cs",
              "ViewState": "AgIAAEYAAAAAAAAAAAAcwF0AAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:06:03.082Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 9,
              "Title": "UserController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\UserController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\UserController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\UserController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\UserController.cs",
              "ViewState": "AgIAAF8AAAAAAAAAAAAcwHYAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:04:17.426Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 8,
              "Title": "WalletController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\WalletController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\WalletController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\WalletController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\WalletController.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAIoAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:04:34.983Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 15,
              "Title": "BillPaymentController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\BillPaymentController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\BillPaymentController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\BillPaymentController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\BillPaymentController.cs",
              "ViewState": "AgIAAGcAAAAAAAAAAAAcwH4AAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:05:50.673Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 14,
              "Title": "FakeBankController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\FakeBankController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\FakeBankController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\FakeBankController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\FakeBankController.cs",
              "ViewState": "AgIAAHEAAAAAAAAAAAAcwIgAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:05:34.813Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 13,
              "Title": "MoneyRequestController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\MoneyRequestController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\MoneyRequestController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\MoneyRequestController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\MoneyRequestController.cs",
              "ViewState": "AgIAAHUAAAAAAAAAAAAcwIwAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:05:13.773Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 10,
              "Title": "TransferController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\TransferController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\TransferController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\TransferController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\TransferController.cs",
              "ViewState": "AgIAAFUAAAAAAAAAAAAcwGwAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:05:09.141Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 11,
              "Title": "TransactionController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\TransactionController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\TransactionController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\TransactionController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\TransactionController.cs",
              "ViewState": "AgIAAGAAAAAAAAAAAAAcwHcAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:04:39.251Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 16,
              "Title": "BaseController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\BaseController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\BaseController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\BaseController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\BaseController.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAAUAAAABAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:08:16.161Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 18,
              "Title": "AdminController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AdminController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\AdminController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AdminController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\AdminController.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:03:02.621Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 17,
              "Title": "AuthController.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AuthController.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Controllers\\AuthController.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Controllers\\AuthController.cs",
              "RelativeToolTip": "DigitalWallet.API\\Controllers\\AuthController.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAKsAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T23:03:33.591Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 19,
              "Title": "Program.cs",
              "DocumentMoniker": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Program.cs",
              "RelativeDocumentMoniker": "DigitalWallet.API\\Program.cs",
              "ToolTip": "C:\\Users\\SoftLaptop\\Desktop\\DigitalWallet-Graduation-Project-\\DigitalWallet.API\\Program.cs",
              "RelativeToolTip": "DigitalWallet.API\\Program.cs",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.000738|",
              "WhenOpened": "2026-02-02T22:57:20.191Z",
              "EditorCaption": ""
            }
          ]
        }
      ]
    }
  ]
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Controllers\AdminController.cs =====
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using DigitalWallet.Application.DTOs.Admin;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Application.Common;

namespace DigitalWallet.API.Controllers
{
    /// <summary>
    /// Admin-only endpoints.  Access is restricted via the "Admin" authorization policy
    /// defined in ServiceCollectionExtensions.  A non-admin token will receive 403.
    /// </summary>
    [Route("api/[controller]")]
    [ApiController]
    [Authorize(Policy = "AdminOnly")]
    public class AdminController : BaseController
    {
        private readonly IAdminService _adminService;
        private readonly ILogger<AdminController> _logger;

        public AdminController(IAdminService adminService, ILogger<AdminController> logger)
        {
            _adminService = adminService;
            _logger = logger;
        }

        /// <summary>
        /// Returns all registered users across the platform.
        /// Intended for the admin dashboard.
        /// </summary>
        /// <returns>Collection of UserManagementDto.</returns>
        /// <response code="200">User list retrieved.</response>
        /// <response code="403">Caller does not have admin privileges.</response>
        [HttpGet("users")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status403Forbidden)]
        public async Task<ActionResult<ApiResponse<IEnumerable<UserManagementDto>>>> GetAllUsers()
        {
            _logger.LogInformation("Admin: Fetching all users.");

            var result = await _adminService.GetAllUsersAsync();

            if (!result.IsSuccess)
            {
                _logger.LogError("Admin GetAllUsers failed. Errors: {Errors}",
                    string.Join(", ", result.Errors ?? Array.Empty<string>()));
                return BadRequest(ApiResponse<IEnumerable<UserManagementDto>>.ErrorResponse(
                    result.Errors ?? new List<string> { "Failed to retrieve users" }));
            }

            return Ok(ApiResponse<IEnumerable<UserManagementDto>>.SuccessResponse(result.Data!));
        }

        /// <summary>
        /// Returns the most recent fraud-log entries (last 24 hours by default, controlled in the service).
        /// </summary>
        /// <returns>Collection of FraudLogDto.</returns>
        /// <response code="200">Fraud logs retrieved.</response>
        /// <response code="403">Caller does not have admin privileges.</response>
        [HttpGet("fraud-logs")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status403Forbidden)]
        public async Task<ActionResult<ApiResponse<IEnumerable<FraudLogDto>>>> GetFraudLogs()
        {
            _logger.LogInformation("Admin: Fetching recent fraud logs.");

            var result = await _adminService.GetFraudLogsAsync();

            if (!result.IsSuccess)
            {
                _logger.LogError("Admin GetFraudLogs failed. Errors: {Errors}",
                    string.Join(", ", result.Errors ?? Array.Empty<string>()));
                return BadRequest(ApiResponse<IEnumerable<FraudLogDto>>.ErrorResponse(
                    result.Errors ?? new List<string> { "Failed to retrieve fraud logs" }));
            }

            return Ok(ApiResponse<IEnumerable<FraudLogDto>>.SuccessResponse(result.Data!));
        }

        /// <summary>
        /// Health-check / connectivity probe for the admin panel.
        /// Returns basic server metadata; useful for monitoring dashboards.
        /// </summary>
        /// <returns>Object with timestamp and environment.</returns>
        /// <response code="200">Server is healthy.</response>
        [HttpGet("health")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public ActionResult<ApiResponse<object>> Health()
        {
            var healthData = new
            {
                Status = "Healthy",
                Timestamp = DateTime.UtcNow,
                Environment = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "Production"
            };

            return Ok(ApiResponse<object>.SuccessResponse(healthData, "Service is healthy"));
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Controllers\AuthController.cs =====
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using DigitalWallet.Application.DTOs.Auth;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Application.Common;

namespace DigitalWallet.API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AuthController : BaseController
    {
        private readonly IAuthService _authService;
        private readonly ILogger<AuthController> _logger;

        public AuthController(IAuthService authService, ILogger<AuthController> logger)
        {
            _authService = authService;
            _logger = logger;
        }

        /// <summary>
        /// Registers a new user account and creates a default EGP wallet.
        /// </summary>
        /// <param name="request">Registration details (name, email, phone, password).</param>
        /// <returns>Token, refresh token, and user summary on success.</returns>
        /// <response code="201">User registered successfully.</response>
        /// <response code="400">Validation failed or email/phone already exists.</response>
        [HttpPost("register")]
        [AllowAnonymous]
        [ProducesResponseType(StatusCodes.Status201Created)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<ActionResult<ApiResponse<LoginResponseDto>>> Register([FromBody] RegisterRequestDto request)
        {
            _logger.LogInformation("Registration attempt for email: {Email}", request.Email);

            var result = await _authService.RegisterAsync(request);

            if (!result.IsSuccess)
            {
                _logger.LogWarning("Registration failed for email: {Email}. Errors: {Errors}",
                    request.Email, string.Join(", ", result.Errors ?? Array.Empty<string>()));

                return BadRequest(ApiResponse<LoginResponseDto>.ErrorResponse(
                    result.Errors ?? new List<string> { "Registration failed" }));
            }

            _logger.LogInformation("Registration successful for UserId: {UserId}", result.Data?.UserId);

            return CreatedAtAction(
                nameof(Register),
                null,
                ApiResponse<LoginResponseDto>.SuccessResponse(result.Data!, result.Message));
        }

        /// <summary>
        /// Authenticates a user using email or phone number plus password.
        /// Returns a token and flags whether OTP verification is still required.
        /// </summary>
        /// <param name="request">Login credentials (email/phone and password).</param>
        /// <returns>Token and login metadata on success.</returns>
        /// <response code="200">Login successful.</response>
        /// <response code="400">Invalid credentials or account suspended.</response>
        [HttpPost("login")]
        [AllowAnonymous]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<ActionResult<ApiResponse<LoginResponseDto>>> Login([FromBody] LoginRequestDto request)
        {
            _logger.LogInformation("Login attempt for identifier: {Identifier}", request.EmailOrPhone);

            var result = await _authService.LoginAsync(request);

            if (!result.IsSuccess)
            {
                _logger.LogWarning("Login failed for identifier: {Identifier}. Errors: {Errors}",
                    request.EmailOrPhone, string.Join(", ", result.Errors ?? Array.Empty<string>()));

                return BadRequest(ApiResponse<LoginResponseDto>.ErrorResponse(
                    result.Errors ?? new List<string> { "Login failed" }));
            }

            _logger.LogInformation("Login successful for UserId: {UserId}", result.Data?.UserId);

            return Ok(ApiResponse<LoginResponseDto>.SuccessResponse(result.Data!, result.Message));
        }

        /// <summary>
        /// Verifies a 6-digit OTP code sent to the user after login or for sensitive operations.
        /// </summary>
        /// <param name="request">UserId and the OTP code to verify.</param>
        /// <returns>Success flag indicating OTP is valid.</returns>
        /// <response code="200">OTP verified.</response>
        /// <response code="400">OTP invalid, expired, or already used.</response>
        [HttpPost("verify-otp")]
        [AllowAnonymous]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<ActionResult<ApiResponse<bool>>> VerifyOtp([FromBody] VerifyOtpRequestDto request)
        {
            if (request.UserId == Guid.Empty)
                return BadRequest(ApiResponse<bool>.ErrorResponse("User ID is required."));

            if (string.IsNullOrWhiteSpace(request.Code) || request.Code.Length != 6)
                return BadRequest(ApiResponse<bool>.ErrorResponse("OTP code must be exactly 6 digits."));

            _logger.LogInformation("OTP verification attempt for UserId: {UserId}", request.UserId);

            var result = await _authService.VerifyOtpAsync(request);
            return HandleResult(result, "OTP verified successfully");
        }

        /// <summary>
        /// Generates a new OTP for a given user and purpose (login or transfer).
        /// In development, the OTP code is returned directly in the response.
        /// </summary>
        /// <param name="userId">Target user's unique identifier.</param>
        /// <param name="type">OTP purpose: "login" or "transfer".</param>
        /// <returns>The generated OTP code (dev-only).</returns>
        /// <response code="200">OTP generated.</response>
        /// <response code="400">Invalid parameters or generation failed.</response>
        [HttpPost("generate-otp/{userId}")]
        [Authorize]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<ActionResult<ApiResponse<string>>> GenerateOtp(
            [FromRoute] Guid userId,
            [FromQuery] string type = "login")
        {
            if (userId == Guid.Empty)
                return BadRequest(ApiResponse<string>.ErrorResponse("Valid User ID is required."));

            var allowedTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { "login", "transfer" };
            if (!allowedTypes.Contains(type))
                return BadRequest(ApiResponse<string>.ErrorResponse("Type must be 'login' or 'transfer'."));

            // In production you would verify the authenticated user matches userId
            // or has admin privileges before generating OTP on behalf of another user.
            var currentUserId = GetCurrentUserId();
            if (currentUserId != userId)
                return Forbid("You can only generate OTP for your own account.");

            _logger.LogInformation("OTP generation requested for UserId: {UserId}, Type: {Type}", userId, type);

            var result = await _authService.GenerateOtpAsync(userId, type);
            return HandleResult(result, "OTP generated successfully");
        }

        /// <summary>
        /// Refreshes an authentication token using a valid refresh token.
        /// </summary>
        /// <param name="request">The refresh token to validate.</param>
        /// <returns>New token pair on success.</returns>
        /// <response code="200">Token refreshed.</response>
        /// <response code="400">Refresh token invalid or expired.</response>
        [HttpPost("refresh-token")]
        [AllowAnonymous]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<ActionResult<ApiResponse<LoginResponseDto>>> RefreshToken([FromBody] RefreshTokenRequestDto request)
        {
            if (string.IsNullOrWhiteSpace(request.RefreshToken))
                return BadRequest(ApiResponse<LoginResponseDto>.ErrorResponse("Refresh token is required."));

            // TODO: Implement full refresh-token rotation logic in AuthService.
            // This stub returns an error until the service method is wired up.
            _logger.LogWarning("RefreshToken endpoint called but full logic is not yet implemented.");
            return BadRequest(ApiResponse<LoginResponseDto>.ErrorResponse("Refresh token feature is pending implementation."));
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Controllers\BaseController.cs =====
using Microsoft.AspNetCore.Mvc;
using DigitalWallet.Application.Common;
using System.Security.Claims;

namespace DigitalWallet.API.Controllers
{
    [ApiController]
    public abstract class BaseController : ControllerBase
    {
        /// <summary>
        /// Extracts the authenticated user's ID from the JWT claims.
        /// Throws UnauthorizedAccessException if the claim is missing or invalid.
        /// </summary>
        protected Guid GetCurrentUserId()
        {
            var userIdClaim = User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;

            if (string.IsNullOrEmpty(userIdClaim))
                throw new UnauthorizedAccessException("User is not authenticated.");

            if (!Guid.TryParse(userIdClaim, out var userId))
                throw new UnauthorizedAccessException("Invalid user identifier in token.");

            return userId;
        }

        /// <summary>
        /// Wraps a successful ServiceResult into an appropriate HTTP response.
        /// </summary>
        protected ActionResult<ApiResponse<T>> HandleResult<T>(ServiceResult<T> result, string? successMessage = null)
        {
            if (!result.IsSuccess)
                return BadRequest(ApiResponse<T>.ErrorResponse(result.Errors ?? new List<string> { "Unknown error" }));

            return Ok(ApiResponse<T>.SuccessResponse(result.Data!, successMessage ?? result.Message));
        }

        /// <summary>
        /// Wraps a successful ServiceResult into a CreatedAtAction response (201).
        /// </summary>
        protected ActionResult<ApiResponse<T>> HandleCreatedResult<T>(ServiceResult<T> result, string actionName, object? routeValues = null, string? successMessage = null)
        {
            if (!result.IsSuccess)
                return BadRequest(ApiResponse<T>.ErrorResponse(result.Errors ?? new List<string> { "Unknown error" }));

            return CreatedAtAction(actionName, routeValues, ApiResponse<T>.SuccessResponse(result.Data!, successMessage ?? result.Message));
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Controllers\BillPaymentController.cs =====
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using DigitalWallet.Application.DTOs.BillPayment;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Application.Common;

namespace DigitalWallet.API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class BillPaymentController : BaseController
    {
        private readonly IBillPaymentService _billPaymentService;
        private readonly IWalletService _walletService;
        private readonly ILogger<BillPaymentController> _logger;

        public BillPaymentController(
            IBillPaymentService billPaymentService,
            IWalletService walletService,
            ILogger<BillPaymentController> logger)
        {
            _billPaymentService = billPaymentService;
            _walletService = walletService;
            _logger = logger;
        }

        /// <summary>
        /// Returns all active billers available for payment.
        /// This endpoint is read-only and does not require ownership checks.
        /// </summary>
        /// <returns>Collection of BillerDto.</returns>
        /// <response code="200">Biller list retrieved.</response>
        [HttpGet("billers")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<IEnumerable<BillerDto>>>> GetBillers()
        {
            _logger.LogInformation("Fetching all active billers.");

            var result = await _billPaymentService.GetAllBillersAsync();
            return HandleResult(result);
        }

        /// <summary>
        /// Pays a bill by deducting the specified amount from the caller's wallet.
        /// Requires a valid OTP, and the wallet referenced in the request must belong to the caller.
        /// </summary>
        /// <param name="request">WalletId, BillerId, Amount, and OTP code.</param>
        /// <returns>BillPaymentDto with receipt path on success.</returns>
        /// <response code="200">Bill paid successfully.</response>
        /// <response code="400">Validation failure, invalid OTP, or insufficient balance.</response>
        /// <response code="403">Wallet does not belong to the caller.</response>
        [HttpPost("pay")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status403Forbidden)]
        public async Task<ActionResult<ApiResponse<BillPaymentDto>>> PayBill([FromBody] PayBillRequestDto request)
        {
            // ── Input validation ──────────────────────────────────────────────
            if (request.WalletId == Guid.Empty)
                return BadRequest(ApiResponse<BillPaymentDto>.ErrorResponse("Wallet ID is required."));

            if (request.BillerId == Guid.Empty)
                return BadRequest(ApiResponse<BillPaymentDto>.ErrorResponse("Biller ID is required."));

            if (request.Amount <= 0)
                return BadRequest(ApiResponse<BillPaymentDto>.ErrorResponse("Payment amount must be greater than zero."));

            if (string.IsNullOrWhiteSpace(request.OtpCode) || request.OtpCode.Length != 6)
                return BadRequest(ApiResponse<BillPaymentDto>.ErrorResponse("A valid 6-digit OTP code is required."));

            // Ensure only digits in OTP
            if (!request.OtpCode.All(char.IsDigit))
                return BadRequest(ApiResponse<BillPaymentDto>.ErrorResponse("OTP code must contain only digits."));

            // ── Ownership guard ──────────────────────────────────────────────
            var currentUserId = GetCurrentUserId();
            var walletResult = await _walletService.GetWalletByIdAsync(request.WalletId);

            if (!walletResult.IsSuccess)
                return BadRequest(ApiResponse<BillPaymentDto>.ErrorResponse("Wallet not found."));

            if (walletResult.Data!.UserId != currentUserId)
            {
                _logger.LogWarning("UserId {CurrentId} attempted to pay bill using WalletId {WalletId} owned by {OwnerId}.",
                    currentUserId, request.WalletId, walletResult.Data.UserId);
                return Forbid("You can only pay bills from your own wallet.");
            }

            // ── Execute payment ───────────────────────────────────────────────
            _logger.LogInformation("PayBill initiated by UserId: {UserId}, BillerId: {BillerId}, Amount: {Amount}",
                currentUserId, request.BillerId, request.Amount);

            var result = await _billPaymentService.PayBillAsync(currentUserId, request);

            if (!result.IsSuccess)
            {
                _logger.LogWarning("PayBill failed for UserId: {UserId}. Errors: {Errors}",
                    currentUserId, string.Join(", ", result.Errors ?? Array.Empty<string>()));
                return BadRequest(ApiResponse<BillPaymentDto>.ErrorResponse(
                    result.Errors ?? new List<string> { "Bill payment failed" }));
            }

            _logger.LogInformation("PayBill succeeded for UserId: {UserId}, PaymentId: {PaymentId}",
                currentUserId, result.Data?.Id);

            return Ok(ApiResponse<BillPaymentDto>.SuccessResponse(result.Data!, result.Message));
        }

        /// <summary>
        /// Returns all bill payments made by the authenticated user.
        /// </summary>
        /// <returns>Collection of BillPaymentDto.</returns>
        /// <response code="200">Payment history retrieved (may be empty).</response>
        [HttpGet("my-payments")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<IEnumerable<BillPaymentDto>>>> GetMyPayments()
        {
            var currentUserId = GetCurrentUserId();
            _logger.LogInformation("Fetching bill payments for UserId: {UserId}", currentUserId);

            var result = await _billPaymentService.GetUserBillPaymentsAsync(currentUserId);
            return HandleResult(result);
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Controllers\FakeBankController.cs =====
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using DigitalWallet.Application.DTOs.FakeBank;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Application.Common;

namespace DigitalWallet.API.Controllers
{
    /// <summary>
    /// Simulates a bank gateway for deposit and withdrawal operations.
    /// All monetary operations include a short artificial delay to mimic real bank processing.
    /// </summary>
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class FakeBankController : BaseController
    {
        private readonly IFakeBankService _fakeBankService;
        private readonly ILogger<FakeBankController> _logger;

        public FakeBankController(IFakeBankService fakeBankService, ILogger<FakeBankController> logger)
        {
            _fakeBankService = fakeBankService;
            _logger = logger;
        }

        /// <summary>
        /// Deposits funds from the simulated external bank account into the user's wallet.
        /// The amount is deducted from the FakeBankAccount and credited to the first wallet.
        /// </summary>
        /// <param name="request">UserId and the deposit Amount.</param>
        /// <returns>FakeBankTransactionDto with status and simulated delay info.</returns>
        /// <response code="200">Deposit completed successfully.</response>
        /// <response code="400">
        /// Insufficient bank balance, amount out of range, or UserId mismatch.
        /// </response>
        /// <response code="403">Caller is not the target user.</response>
        [HttpPost("deposit")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status403Forbidden)]
        public async Task<ActionResult<ApiResponse<FakeBankTransactionDto>>> Deposit([FromBody] DepositRequestDto request)
        {
            // ── Input validation ──────────────────────────────────────────────
            if (request.UserId == Guid.Empty)
                return BadRequest(ApiResponse<FakeBankTransactionDto>.ErrorResponse("User ID is required."));

            if (request.Amount <= 0)
                return BadRequest(ApiResponse<FakeBankTransactionDto>.ErrorResponse("Deposit amount must be greater than zero."));

            if (request.Amount > 100_000m)
                return BadRequest(ApiResponse<FakeBankTransactionDto>.ErrorResponse("Deposit amount cannot exceed 100,000."));

            // ── Ownership guard ──────────────────────────────────────────────
            var currentUserId = GetCurrentUserId();
            if (currentUserId != request.UserId)
            {
                _logger.LogWarning("UserId {CurrentId} attempted to deposit on behalf of UserId {TargetId}.",
                    currentUserId, request.UserId);
                return Forbid("You can only perform deposits into your own account.");
            }

            _logger.LogInformation("Deposit initiated by UserId: {UserId}, Amount: {Amount}",
                request.UserId, request.Amount);

            var result = await _fakeBankService.DepositAsync(request);

            if (!result.IsSuccess)
            {
                _logger.LogWarning("Deposit failed for UserId: {UserId}. Errors: {Errors}",
                    request.UserId, string.Join(", ", result.Errors ?? Array.Empty<string>()));
                return BadRequest(ApiResponse<FakeBankTransactionDto>.ErrorResponse(
                    result.Errors ?? new List<string> { "Deposit failed" }));
            }

            _logger.LogInformation("Deposit succeeded for UserId: {UserId}, TxnId: {TxnId}",
                request.UserId, result.Data?.Id);

            return Ok(ApiResponse<FakeBankTransactionDto>.SuccessResponse(result.Data!, result.Message));
        }

        /// <summary>
        /// Withdraws funds from the user's wallet and credits the simulated bank account.
        /// </summary>
        /// <param name="request">UserId and the withdrawal Amount.</param>
        /// <returns>FakeBankTransactionDto with status and simulated delay info.</returns>
        /// <response code="200">Withdrawal completed successfully.</response>
        /// <response code="400">
        /// Insufficient wallet balance, amount out of range, or UserId mismatch.
        /// </response>
        /// <response code="403">Caller is not the target user.</response>
        [HttpPost("withdraw")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status403Forbidden)]
        public async Task<ActionResult<ApiResponse<FakeBankTransactionDto>>> Withdraw([FromBody] WithdrawRequestDto request)
        {
            // ── Input validation ──────────────────────────────────────────────
            if (request.UserId == Guid.Empty)
                return BadRequest(ApiResponse<FakeBankTransactionDto>.ErrorResponse("User ID is required."));

            if (request.Amount <= 0)
                return BadRequest(ApiResponse<FakeBankTransactionDto>.ErrorResponse("Withdrawal amount must be greater than zero."));

            if (request.Amount > 100_000m)
                return BadRequest(ApiResponse<FakeBankTransactionDto>.ErrorResponse("Withdrawal amount cannot exceed 100,000."));

            // ── Ownership guard ──────────────────────────────────────────────
            var currentUserId = GetCurrentUserId();
            if (currentUserId != request.UserId)
            {
                _logger.LogWarning("UserId {CurrentId} attempted to withdraw on behalf of UserId {TargetId}.",
                    currentUserId, request.UserId);
                return Forbid("You can only perform withdrawals from your own account.");
            }

            _logger.LogInformation("Withdraw initiated by UserId: {UserId}, Amount: {Amount}",
                request.UserId, request.Amount);

            var result = await _fakeBankService.WithdrawAsync(request);

            if (!result.IsSuccess)
            {
                _logger.LogWarning("Withdraw failed for UserId: {UserId}. Errors: {Errors}",
                    request.UserId, string.Join(", ", result.Errors ?? Array.Empty<string>()));
                return BadRequest(ApiResponse<FakeBankTransactionDto>.ErrorResponse(
                    result.Errors ?? new List<string> { "Withdrawal failed" }));
            }

            _logger.LogInformation("Withdraw succeeded for UserId: {UserId}, TxnId: {TxnId}",
                request.UserId, result.Data?.Id);

            return Ok(ApiResponse<FakeBankTransactionDto>.SuccessResponse(result.Data!, result.Message));
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Controllers\MoneyRequestController.cs =====
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using DigitalWallet.Application.DTOs.MoneyRequest;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Application.Common;

namespace DigitalWallet.API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class MoneyRequestController : BaseController
    {
        private readonly IMoneyRequestService _moneyRequestService;
        private readonly ILogger<MoneyRequestController> _logger;

        public MoneyRequestController(
            IMoneyRequestService moneyRequestService,
            ILogger<MoneyRequestController> logger)
        {
            _moneyRequestService = moneyRequestService;
            _logger = logger;
        }

        /// <summary>
        /// Creates a new money request directed at another user.
        /// The service layer prevents users from requesting money from themselves.
        /// </summary>
        /// <param name="request">Target user identifier, amount, and currency.</param>
        /// <returns>MoneyRequestDto with pending status.</returns>
        /// <response code="201">Request created.</response>
        /// <response code="400">Target not found, self-request, or validation error.</response>
        [HttpPost]
        [ProducesResponseType(StatusCodes.Status201Created)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<ActionResult<ApiResponse<MoneyRequestDto>>> CreateRequest([FromBody] CreateMoneyRequestDto request)
        {
            // ── Input validation ──────────────────────────────────────────────
            if (string.IsNullOrWhiteSpace(request.ToUserPhoneOrEmail))
                return BadRequest(ApiResponse<MoneyRequestDto>.ErrorResponse("Target user phone or email is required."));

            if (request.Amount <= 0)
                return BadRequest(ApiResponse<MoneyRequestDto>.ErrorResponse("Amount must be greater than zero."));

            if (string.IsNullOrWhiteSpace(request.CurrencyCode))
                request.CurrencyCode = "EGP"; // default fallback

            var currentUserId = GetCurrentUserId();
            _logger.LogInformation("CreateMoneyRequest by UserId: {UserId}, Target: {Target}, Amount: {Amount}",
                currentUserId, request.ToUserPhoneOrEmail, request.Amount);

            var result = await _moneyRequestService.CreateRequestAsync(currentUserId, request);

            if (!result.IsSuccess)
            {
                _logger.LogWarning("CreateMoneyRequest failed for UserId: {UserId}. Errors: {Errors}",
                    currentUserId, string.Join(", ", result.Errors ?? Array.Empty<string>()));
                return BadRequest(ApiResponse<MoneyRequestDto>.ErrorResponse(
                    result.Errors ?? new List<string> { "Failed to create request" }));
            }

            return CreatedAtAction(
                nameof(GetSentRequests),
                null,
                ApiResponse<MoneyRequestDto>.SuccessResponse(result.Data!, result.Message));
        }

        /// <summary>
        /// Lists all money requests that the authenticated user has sent.
        /// </summary>
        /// <returns>Collection of MoneyRequestDto (sent).</returns>
        /// <response code="200">List retrieved.</response>
        [HttpGet("sent")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<IEnumerable<MoneyRequestDto>>>> GetSentRequests()
        {
            var currentUserId = GetCurrentUserId();
            _logger.LogInformation("Fetching sent requests for UserId: {UserId}", currentUserId);

            var result = await _moneyRequestService.GetSentRequestsAsync(currentUserId);
            return HandleResult(result);
        }

        /// <summary>
        /// Lists all money requests that have been sent TO the authenticated user (pending responses).
        /// </summary>
        /// <returns>Collection of MoneyRequestDto (received).</returns>
        /// <response code="200">List retrieved.</response>
        [HttpGet("received")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<IEnumerable<MoneyRequestDto>>>> GetReceivedRequests()
        {
            var currentUserId = GetCurrentUserId();
            _logger.LogInformation("Fetching received requests for UserId: {UserId}", currentUserId);

            var result = await _moneyRequestService.GetReceivedRequestsAsync(currentUserId);
            return HandleResult(result);
        }

        /// <summary>
        /// Accepts or rejects a money request addressed to the authenticated user.
        /// Accepting requires a valid OTP; rejection does not.
        /// The service layer verifies that the request belongs to the caller and is still pending.
        /// </summary>
        /// <param name="request">RequestId, Accept flag, and (if accepting) OTP code.</param>
        /// <returns>Boolean success indicator.</returns>
        /// <response code="200">Request responded to.</response>
        /// <response code="400">
        /// Request not found, already processed, OTP missing/invalid, or insufficient balance.
        /// </response>
        [HttpPut("respond")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<ActionResult<ApiResponse<bool>>> RespondToRequest([FromBody] AcceptRejectRequestDto request)
        {
            if (request.RequestId == Guid.Empty)
                return BadRequest(ApiResponse<bool>.ErrorResponse("Request ID is required."));

            // OTP is mandatory only when accepting
            if (request.Accept && (string.IsNullOrWhiteSpace(request.OtpCode) || request.OtpCode.Length != 6))
                return BadRequest(ApiResponse<bool>.ErrorResponse("A valid 6-digit OTP code is required to accept a request."));

            var currentUserId = GetCurrentUserId();
            _logger.LogInformation("RespondToRequest by UserId: {UserId}, RequestId: {RequestId}, Accept: {Accept}",
                currentUserId, request.RequestId, request.Accept);

            var result = await _moneyRequestService.RespondToRequestAsync(currentUserId, request);

            if (!result.IsSuccess)
            {
                _logger.LogWarning("RespondToRequest failed for UserId: {UserId}. Errors: {Errors}",
                    currentUserId, string.Join(", ", result.Errors ?? Array.Empty<string>()));
                return BadRequest(ApiResponse<bool>.ErrorResponse(
                    result.Errors ?? new List<string> { "Failed to respond to request" }));
            }

            return Ok(ApiResponse<bool>.SuccessResponse(result.Data, result.Message));
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Controllers\NotificationController.cs =====
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using DigitalWallet.Application.DTOs.Notification;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Application.Common;

namespace DigitalWallet.API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class NotificationController : BaseController
    {
        private readonly INotificationService _notificationService;
        private readonly ILogger<NotificationController> _logger;

        public NotificationController(
            INotificationService notificationService,
            ILogger<NotificationController> logger)
        {
            _notificationService = notificationService;
            _logger = logger;
        }

        /// <summary>
        /// Returns a paginated list of all notifications for the authenticated user,
        /// ordered from newest to oldest.
        /// </summary>
        /// <param name="pageNumber">1-based page index (default 1).</param>
        /// <param name="pageSize">Items per page (default 20, max 100).</param>
        /// <returns>Collection of NotificationDto.</returns>
        /// <response code="200">Notifications retrieved.</response>
        /// <response code="400">Invalid pagination parameters.</response>
        [HttpGet]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<ActionResult<ApiResponse<IEnumerable<NotificationDto>>>> GetNotifications(
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 20)
        {
            if (pageNumber < 1)
                return BadRequest(ApiResponse<IEnumerable<NotificationDto>>.ErrorResponse("Page number must be at least 1."));

            if (pageSize < 1 || pageSize > 100)
                return BadRequest(ApiResponse<IEnumerable<NotificationDto>>.ErrorResponse("Page size must be between 1 and 100."));

            var currentUserId = GetCurrentUserId();
            _logger.LogInformation("Fetching notifications for UserId: {UserId}, Page: {Page}, Size: {Size}",
                currentUserId, pageNumber, pageSize);

            var result = await _notificationService.GetUserNotificationsAsync(currentUserId, pageNumber, pageSize);
            return HandleResult(result);
        }

        /// <summary>
        /// Marks a single notification as read.
        /// </summary>
        /// <param name="notificationId">The notification to mark.</param>
        /// <returns>Boolean success flag.</returns>
        /// <response code="200">Notification marked as read.</response>
        /// <response code="400">Invalid notificationId.</response>
        [HttpPut("{notificationId:guid}/read")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<ActionResult<ApiResponse<bool>>> MarkAsRead([FromRoute] Guid notificationId)
        {
            if (notificationId == Guid.Empty)
                return BadRequest(ApiResponse<bool>.ErrorResponse("A valid Notification ID is required."));

            _logger.LogInformation("Marking notification {NotificationId} as read.", notificationId);

            var result = await _notificationService.MarkAsReadAsync(notificationId);
            return HandleResult(result, "Notification marked as read");
        }

        /// <summary>
        /// Returns the count of unread notifications for the authenticated user.
        /// Useful for badge counters on the mobile / web UI.
        /// </summary>
        /// <returns>Integer unread count.</returns>
        /// <response code="200">Count retrieved.</response>
        [HttpGet("unread-count")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<int>>> GetUnreadCount()
        {
            var currentUserId = GetCurrentUserId();
            _logger.LogInformation("Fetching unread notification count for UserId: {UserId}", currentUserId);

            var result = await _notificationService.GetUnreadCountAsync(currentUserId);
            return HandleResult(result);
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Controllers\TransactionController.cs =====
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using DigitalWallet.Application.DTOs.Transaction;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Application.Common;

namespace DigitalWallet.API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class TransactionController : BaseController
    {
        private readonly ITransactionService _transactionService;
        private readonly IWalletService _walletService;
        private readonly ILogger<TransactionController> _logger;

        public TransactionController(
            ITransactionService transactionService,
            IWalletService walletService,
            ILogger<TransactionController> logger)
        {
            _transactionService = transactionService;
            _walletService = walletService;
            _logger = logger;
        }

        /// <summary>
        /// Returns a single transaction by its ID.
        /// The transaction's wallet must belong to the authenticated user.
        /// </summary>
        /// <param name="transactionId">Unique identifier of the transaction.</param>
        /// <returns>TransactionDto if found and owned by the caller.</returns>
        /// <response code="200">Transaction found.</response>
        /// <response code="400">Invalid transactionId.</response>
        /// <response code="404">Transaction does not exist or does not belong to you.</response>
        [HttpGet("{transactionId:guid}")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<ActionResult<ApiResponse<TransactionDto>>> GetTransaction([FromRoute] Guid transactionId)
        {
            if (transactionId == Guid.Empty)
                return BadRequest(ApiResponse<TransactionDto>.ErrorResponse("A valid Transaction ID is required."));

            _logger.LogInformation("Fetching transaction {TransactionId}", transactionId);

            var result = await _transactionService.GetTransactionByIdAsync(transactionId);

            if (!result.IsSuccess)
                return NotFound(ApiResponse<TransactionDto>.ErrorResponse("Transaction not found."));

            // Ownership: verify the wallet referenced by this transaction belongs to the caller
            var currentUserId = GetCurrentUserId();
            var walletResult = await _walletService.GetWalletByIdAsync(result.Data!.WalletId);

            if (!walletResult.IsSuccess || walletResult.Data!.UserId != currentUserId)
            {
                _logger.LogWarning("UserId {CurrentId} attempted to view transaction {TxnId} belonging to another user.",
                    currentUserId, transactionId);
                return NotFound(ApiResponse<TransactionDto>.ErrorResponse("Transaction not found."));
            }

            return Ok(ApiResponse<TransactionDto>.SuccessResponse(result.Data));
        }

        /// <summary>
        /// Returns a paginated list of transactions for a given wallet.
        /// The wallet must belong to the authenticated user.
        /// </summary>
        /// <param name="walletId">Wallet whose transactions are requested.</param>
        /// <param name="pageNumber">1-based page index (default 1).</param>
        /// <param name="pageSize">Number of items per page (default 20, max 100).</param>
        /// <returns>PaginatedResult containing TransactionDto items.</returns>
        /// <response code="200">Page of transactions retrieved.</response>
        /// <response code="400">Invalid parameters.</response>
        /// <response code="404">Wallet not found or not owned by you.</response>
        [HttpGet("wallet/{walletId:guid}")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<ActionResult<ApiResponse<PaginatedResult<TransactionDto>>>> GetWalletTransactions(
            [FromRoute] Guid walletId,
            [FromQuery] int pageNumber = 1,
            [FromQuery] int pageSize = 20)
        {
            // ── Input validation ──────────────────────────────────────────────
            if (walletId == Guid.Empty)
                return BadRequest(ApiResponse<PaginatedResult<TransactionDto>>.ErrorResponse("A valid Wallet ID is required."));

            if (pageNumber < 1)
                return BadRequest(ApiResponse<PaginatedResult<TransactionDto>>.ErrorResponse("Page number must be at least 1."));

            if (pageSize < 1 || pageSize > 100)
                return BadRequest(ApiResponse<PaginatedResult<TransactionDto>>.ErrorResponse("Page size must be between 1 and 100."));

            // ── Ownership check ──────────────────────────────────────────────
            var currentUserId = GetCurrentUserId();
            var walletResult = await _walletService.GetWalletByIdAsync(walletId);

            if (!walletResult.IsSuccess)
                return NotFound(ApiResponse<PaginatedResult<TransactionDto>>.ErrorResponse("Wallet not found."));

            if (walletResult.Data!.UserId != currentUserId)
            {
                _logger.LogWarning("UserId {CurrentId} tried to list transactions of WalletId {WalletId} owned by {OwnerId}.",
                    currentUserId, walletId, walletResult.Data.UserId);
                return NotFound(ApiResponse<PaginatedResult<TransactionDto>>.ErrorResponse("Wallet not found."));
            }

            // ── Fetch paginated transactions ─────────────────────────────────
            _logger.LogInformation("Fetching transactions for WalletId: {WalletId}, Page: {Page}, Size: {Size}",
                walletId, pageNumber, pageSize);

            var result = await _transactionService.GetWalletTransactionsAsync(walletId, pageNumber, pageSize);
            return HandleResult(result);
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Controllers\TransferController.cs =====
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using DigitalWallet.Application.DTOs.Transfer;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Application.Common;

namespace DigitalWallet.API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class TransferController : BaseController
    {
        private readonly ITransferService _transferService;
        private readonly IWalletService _walletService;
        private readonly ILogger<TransferController> _logger;

        public TransferController(
            ITransferService transferService,
            IWalletService walletService,
            ILogger<TransferController> logger)
        {
            _transferService = transferService;
            _walletService = walletService;
            _logger = logger;
        }

        /// <summary>
        /// Sends money from the authenticated user's wallet to another user
        /// identified by phone number or email.  Requires a valid OTP in the payload.
        /// </summary>
        /// <param name="request">
        /// SenderWalletId, receiver identifier, amount, optional description, and OTP code.
        /// </param>
        /// <returns>TransferResponseDto with confirmation details.</returns>
        /// <response code="200">Transfer completed.</response>
        /// <response code="400">Validation failure, insufficient balance, or invalid OTP.</response>
        /// <response code="403">Sender wallet does not belong to you.</response>
        [HttpPost("send")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status403Forbidden)]
        public async Task<ActionResult<ApiResponse<TransferResponseDto>>> SendMoney([FromBody] SendMoneyRequestDto request)
        {
            // ── Basic field validation ────────────────────────────────────────
            if (request.SenderWalletId == Guid.Empty)
                return BadRequest(ApiResponse<TransferResponseDto>.ErrorResponse("Sender Wallet ID is required."));

            if (string.IsNullOrWhiteSpace(request.ReceiverPhoneOrEmail))
                return BadRequest(ApiResponse<TransferResponseDto>.ErrorResponse("Receiver phone or email is required."));

            if (request.Amount <= 0)
                return BadRequest(ApiResponse<TransferResponseDto>.ErrorResponse("Amount must be greater than zero."));

            if (string.IsNullOrWhiteSpace(request.OtpCode) || request.OtpCode.Length != 6)
                return BadRequest(ApiResponse<TransferResponseDto>.ErrorResponse("A valid 6-digit OTP code is required."));

            // ── Ownership guard ──────────────────────────────────────────────
            var currentUserId = GetCurrentUserId();
            var walletResult = await _walletService.GetWalletByIdAsync(request.SenderWalletId);

            if (!walletResult.IsSuccess)
                return BadRequest(ApiResponse<TransferResponseDto>.ErrorResponse("Sender wallet not found."));

            if (walletResult.Data!.UserId != currentUserId)
            {
                _logger.LogWarning("UserId {CurrentId} attempted to send from WalletId {WalletId} owned by {OwnerId}.",
                    currentUserId, request.SenderWalletId, walletResult.Data.UserId);
                return Forbid("You can only transfer from your own wallet.");
            }

            // ── Execute transfer ──────────────────────────────────────────────
            _logger.LogInformation("SendMoney initiated by UserId: {UserId}, Amount: {Amount}, Receiver: {Receiver}",
                currentUserId, request.Amount, request.ReceiverPhoneOrEmail);

            var result = await _transferService.SendMoneyAsync(request);

            if (!result.IsSuccess)
            {
                _logger.LogWarning("SendMoney failed for UserId: {UserId}. Errors: {Errors}",
                    currentUserId, string.Join(", ", result.Errors ?? Array.Empty<string>()));
                return BadRequest(ApiResponse<TransferResponseDto>.ErrorResponse(
                    result.Errors ?? new List<string> { "Transfer failed" }));
            }

            _logger.LogInformation("SendMoney succeeded. TransferId: {TransferId}",
                result.Data?.TransferId);

            return Ok(ApiResponse<TransferResponseDto>.SuccessResponse(result.Data!, result.Message));
        }

        /// <summary>
        /// Lists all transfers (sent and received) across every wallet the caller owns.
        /// </summary>
        /// <returns>Collection of TransferDto.</returns>
        /// <response code="200">Transfers retrieved (may be empty).</response>
        [HttpGet("my-transfers")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<IEnumerable<TransferDto>>>> GetMyTransfers()
        {
            var currentUserId = GetCurrentUserId();
            _logger.LogInformation("Fetching transfers for UserId: {UserId}", currentUserId);

            var result = await _transferService.GetUserTransfersAsync(currentUserId);
            return HandleResult(result);
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Controllers\UserController.cs =====
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Admin;
using DigitalWallet.Application.DTOs.Auth;
using DigitalWallet.Application.Interfaces.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace DigitalWallet.API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class UserController : BaseController
    {
        private readonly IUserService _userService;
        private readonly ILogger<UserController> _logger;

        public UserController(IUserService userService, ILogger<UserController> logger)
        {
            _userService = userService;
            _logger = logger;
        }

        /// <summary>
        /// Returns the authenticated user's profile fetched by their JWT-embedded user ID.
        /// </summary>
        /// <returns>The current user's DTO.</returns>
        /// <response code="200">Profile retrieved.</response>
        /// <response code="401">Not authenticated.</response>
        /// <response code="404">User record not found in database.</response>
        [HttpGet("me")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status401Unauthorized)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<ActionResult<ApiResponse<UserManagementDto>>> GetCurrentUser()
        {
            var userId = GetCurrentUserId();
            _logger.LogInformation("Fetching profile for UserId: {UserId}", userId);

            var result = await _userService.GetUserByIdAsync(userId);

            if (!result.IsSuccess)
                return NotFound(ApiResponse<UserManagementDto>.ErrorResponse("User profile not found."));

            return Ok(ApiResponse<UserManagementDto>.SuccessResponse(result.Data!));
        }

        /// <summary>
        /// Retrieves a user profile by their unique ID.
        /// Only the owner of the account may access this endpoint; 403 is returned otherwise.
        /// </summary>
        /// <param name="userId">Target user's GUID.</param>
        /// <returns>The requested user's DTO.</returns>
        /// <response code="200">Profile retrieved.</response>
        /// <response code="400">Invalid GUID format.</response>
        /// <response code="403">Authenticated user is not the owner.</response>
        /// <response code="404">No user with the given ID exists.</response>
        [HttpGet("{userId:guid}")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status403Forbidden)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<ActionResult<ApiResponse<UserManagementDto>>> GetUserById([FromRoute] Guid userId)
        {
            if (userId == Guid.Empty)
                return BadRequest(ApiResponse<UserManagementDto>.ErrorResponse("A valid User ID is required."));

            // Privacy guard: only allow fetching your own profile unless you are an admin.
            var currentUserId = GetCurrentUserId();
            if (currentUserId != userId)
            {
                _logger.LogWarning("UserId {CurrentId} attempted to access profile of UserId {TargetId}.",
                    currentUserId, userId);
                return Forbid("You are only allowed to view your own profile.");
            }

            _logger.LogInformation("Fetching profile for UserId: {UserId}", userId);

            var result = await _userService.GetUserByIdAsync(userId);

            if (!result.IsSuccess)
                return NotFound(ApiResponse<UserManagementDto>.ErrorResponse("User not found."));

            return Ok(ApiResponse<UserManagementDto>.SuccessResponse(result.Data!));
        }

        /// <summary>
        /// Looks up a user by email address.
        /// Intended for internal / admin use; regular users should use /me.
        /// </summary>
        /// <param name="email">Email address to search for.</param>
        /// <returns>Matching user DTO if found.</returns>
        /// <response code="200">User found.</response>
        /// <response code="400">Email parameter missing or empty.</response>
        /// <response code="404">No user with the given email.</response>
        [HttpGet("by-email")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<ActionResult<ApiResponse<UserManagementDto>>> GetUserByEmail([FromQuery] string email)
        {
            if (string.IsNullOrWhiteSpace(email))
                return BadRequest(ApiResponse<UserManagementDto>.ErrorResponse("Email parameter is required."));

            // Basic format sanity check
            if (!email.Contains('@'))
                return BadRequest(ApiResponse<UserManagementDto>.ErrorResponse("Invalid email format."));

            _logger.LogInformation("Searching user by email: {Email}", email);

            var result = await _userService.GetUserByEmailAsync(email);

            if (!result.IsSuccess)
                return NotFound(ApiResponse<UserManagementDto>.ErrorResponse("User with the specified email was not found."));

            return Ok(ApiResponse<UserManagementDto>.SuccessResponse(result.Data!));
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Controllers\WalletController.cs =====
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using DigitalWallet.Application.DTOs.Wallet;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Application.Common;

namespace DigitalWallet.API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class WalletController : BaseController
    {
        private readonly IWalletService _walletService;
        private readonly ILogger<WalletController> _logger;

        public WalletController(IWalletService walletService, ILogger<WalletController> logger)
        {
            _walletService = walletService;
            _logger = logger;
        }

        /// <summary>
        /// Returns every wallet that belongs to the currently authenticated user.
        /// </summary>
        /// <returns>List of WalletDto for the caller.</returns>
        /// <response code="200">Wallets retrieved (may be an empty list).</response>
        [HttpGet("my-wallets")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public async Task<ActionResult<ApiResponse<IEnumerable<WalletDto>>>> GetMyWallets()
        {
            var userId = GetCurrentUserId();
            _logger.LogInformation("Fetching wallets for UserId: {UserId}", userId);

            var result = await _walletService.GetUserWalletsAsync(userId);
            return HandleResult(result);
        }

        /// <summary>
        /// Returns the details of a single wallet identified by its GUID.
        /// The wallet must belong to the authenticated user.
        /// </summary>
        /// <param name="walletId">The wallet's unique identifier.</param>
        /// <returns>Single WalletDto.</returns>
        /// <response code="200">Wallet found.</response>
        /// <response code="400">walletId is empty.</response>
        /// <response code="404">No wallet with that ID, or it does not belong to you.</response>
        [HttpGet("{walletId:guid}")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<ActionResult<ApiResponse<WalletDto>>> GetWalletById([FromRoute] Guid walletId)
        {
            if (walletId == Guid.Empty)
                return BadRequest(ApiResponse<WalletDto>.ErrorResponse("A valid Wallet ID is required."));

            var result = await _walletService.GetWalletByIdAsync(walletId);

            if (!result.IsSuccess)
                return NotFound(ApiResponse<WalletDto>.ErrorResponse("Wallet not found."));

            // Ownership check — the wallet must belong to the logged-in user
            var currentUserId = GetCurrentUserId();
            if (result.Data!.UserId != currentUserId)
            {
                _logger.LogWarning("UserId {CurrentId} tried to access WalletId {WalletId} owned by {OwnerId}.",
                    currentUserId, walletId, result.Data.UserId);
                return NotFound(ApiResponse<WalletDto>.ErrorResponse("Wallet not found."));
                // Return 404 (not 403) to avoid leaking the existence of the wallet.
            }

            return Ok(ApiResponse<WalletDto>.SuccessResponse(result.Data));
        }

        /// <summary>
        /// Creates a new wallet for the authenticated user with a specified currency.
        /// Only one wallet per currency is allowed per user.
        /// </summary>
        /// <param name="request">Currency code for the new wallet (default "EGP").</param>
        /// <returns>The newly created WalletDto.</returns>
        /// <response code="201">Wallet created.</response>
        /// <response code="400">Duplicate currency wallet or validation error.</response>
        [HttpPost]
        [ProducesResponseType(StatusCodes.Status201Created)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<ActionResult<ApiResponse<WalletDto>>> CreateWallet([FromBody] CreateWalletRequestDto request)
        {
            var currentUserId = GetCurrentUserId();

            // Always force the UserId to the authenticated caller to prevent spoofing
            request.UserId = currentUserId;

            if (string.IsNullOrWhiteSpace(request.CurrencyCode))
                return BadRequest(ApiResponse<WalletDto>.ErrorResponse("Currency code is required."));

            // Normalise currency to upper-case
            request.CurrencyCode = request.CurrencyCode.Trim().ToUpperInvariant();

            _logger.LogInformation("Creating wallet for UserId: {UserId}, Currency: {Currency}",
                currentUserId, request.CurrencyCode);

            var result = await _walletService.CreateWalletAsync(request);
            return HandleCreatedResult(result, nameof(GetWalletById), new { walletId = result.Data?.Id },
                "Wallet created successfully");
        }

        /// <summary>
        /// Returns the current balance of a specific wallet.
        /// The wallet must belong to the authenticated user.
        /// </summary>
        /// <param name="walletId">The wallet to query.</param>
        /// <returns>WalletBalanceDto with balance and currency.</returns>
        /// <response code="200">Balance retrieved.</response>
        /// <response code="400">Invalid walletId.</response>
        /// <response code="404">Wallet not found or not owned by you.</response>
        [HttpGet("{walletId:guid}/balance")]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<ActionResult<ApiResponse<WalletBalanceDto>>> GetBalance([FromRoute] Guid walletId)
        {
            if (walletId == Guid.Empty)
                return BadRequest(ApiResponse<WalletBalanceDto>.ErrorResponse("A valid Wallet ID is required."));

            // First verify ownership via the full wallet lookup
            var walletResult = await _walletService.GetWalletByIdAsync(walletId);
            if (!walletResult.IsSuccess)
                return NotFound(ApiResponse<WalletBalanceDto>.ErrorResponse("Wallet not found."));

            var currentUserId = GetCurrentUserId();
            if (walletResult.Data!.UserId != currentUserId)
                return NotFound(ApiResponse<WalletBalanceDto>.ErrorResponse("Wallet not found."));

            var result = await _walletService.GetBalanceAsync(walletId);
            return HandleResult(result);
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Extensions\ApplicationBuilderExtensions.cs =====
using Microsoft.AspNetCore.Builder;
using DigitalWallet.API.Middleware;

namespace DigitalWallet.API.Extensions
{
    /// <summary>
    /// Extension methods on <see cref="WebApplication"/> (IApplicationBuilder) that
    /// register and order the custom middleware added by this project.
    ///
    /// Middleware order matters – the methods below should be called in the order
    /// shown in Program.cs.  The comments below explain why each piece sits where it does.
    /// </summary>
    public static class ApplicationBuilderExtensions
    {
        /// <summary>
        /// Adds <see cref="ExceptionHandlingMiddleware"/> as the **outermost** layer so it
        /// can catch exceptions thrown by every other piece of middleware and controller.
        ///
        /// Must be called BEFORE any other Use* / Map* calls on the builder.
        /// </summary>
        public static WebApplication UseExceptionHandling(this WebApplication app)
        {
            app.UseMiddleware<ExceptionHandlingMiddleware>();
            return app;
        }

        /// <summary>
        /// Adds <see cref="RequestLoggingMiddleware"/> immediately after exception handling.
        /// This position means:
        ///   • The stopwatch wraps the full downstream pipeline (auth + controller).
        ///   • Any 5xx from the controller is still logged before ExceptionHandlingMiddleware
        ///     serialises it, because RequestLogging logs on the *way back out*.
        /// </summary>
        public static WebApplication UseRequestLogging(this WebApplication app)
        {
            app.UseMiddleware<RequestLoggingMiddleware>();
            return app;
        }

        /// <summary>
        /// Adds <see cref="JwtMiddleware"/> after logging so that:
        ///   1. The request log already has a correlation ID before auth runs.
        ///   2. If token validation throws (it shouldn't, but defensively) the exception
        ///      is caught by ExceptionHandlingMiddleware.
        ///
        /// This must be called BEFORE app.UseAuthorization() because [Authorize]
        /// attributes inspect HttpContext.User which this middleware populates.
        /// </summary>
        public static WebApplication UseJwtAuthentication(this WebApplication app)
        {
            app.UseMiddleware<JwtMiddleware>();
            return app;
        }

        /// <summary>
        /// Convenience method that registers the three custom middlewares in the
        /// correct order with a single call.  Use this OR the individual methods –
        /// not both.
        /// </summary>
        public static WebApplication UseDigitalWalletMiddleware(this WebApplication app)
        {
            app.UseExceptionHandling();   // 1st – outermost
            app.UseRequestLogging();      // 2nd – wraps everything below
            app.UseJwtAuthentication();   // 3rd – populates HttpContext.User
            return app;
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Extensions\ServiceCollectionExtensions.cs =====
using Microsoft.AspNetCore.Authorization;
using Microsoft.Extensions.DependencyInjection;
using DigitalWallet.API.Filters;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Application.Services;

namespace DigitalWallet.API.Extensions
{
    /// <summary>
    /// Centralised DI wiring for every layer the API depends on.
    /// Call <see cref="AddApplicationServices"/> from Program.cs after
    /// <c>builder.Services</c> is available.
    /// </summary>
    public static class ServiceCollectionExtensions
    {
        /// <summary>
        /// Registers all Application-layer services, validators, mapping profiles,
        /// and the custom authorization policies required by the API.
        /// </summary>
        /// <param name="services">The service collection to extend.</param>
        /// <returns>The same collection for chaining.</returns>
        public static IServiceCollection AddApplicationServices(this IServiceCollection services)
        {
            // ── 1.  Application Services (business logic) ─────────────────────
            // Each interface lives in DigitalWallet.Application.Interfaces.Services
            // and its implementation in DigitalWallet.Application.Services.
            // Scoped lifetime: one instance per HTTP request, shared across all
            // controllers / middleware that participate in that request.

            services.AddScoped<IAuthService, AuthService>();
            services.AddScoped<IUserService, UserService>();
            services.AddScoped<IWalletService, WalletService>();
            services.AddScoped<ITransactionService, TransactionService>();
            services.AddScoped<ITransferService, TransferService>();
            services.AddScoped<IMoneyRequestService, MoneyRequestService>();
            services.AddScoped<IFakeBankService, FakeBankService>();
            services.AddScoped<IBillPaymentService, BillPaymentService>();
            services.AddScoped<INotificationService, NotificationService>();
            services.AddScoped<IAdminService, AdminService>();

            // ── 2.  AutoMapper ────────────────────────────────────────────────
            // Scans DigitalWallet.Application for any class that inherits AutoMapper.Profile
            // (currently MappingProfile.cs) and registers it automatically.
            services.AddAutoMapper(typeof(DigitalWallet.Application.Mappings.MappingProfile).Assembly);

            // ── 3.  FluentValidation ──────────────────────────────────────────
            // Scans the Application assembly for every AbstractValidator<T> subclass
            // and registers them as transient.  The ValidationFilter (or the built-in
            // FluentValidation model validation pipeline) will resolve them at request time.
            //
            // NOTE: If you add FluentValidation.AspNetCore to the API .csproj you can
            // replace this block with:
            //     services.AddFluentValidation(fv => fv.RegisterValidatorsFromAssembly(...));
            // For now we register validators manually to keep the .csproj minimal.

            services.AddTransient<
                FluentValidation.IValidator<DigitalWallet.Application.DTOs.Auth.RegisterRequestDto>,
                DigitalWallet.Application.Validators.RegisterRequestValidator>();

            services.AddTransient<
                FluentValidation.IValidator<DigitalWallet.Application.DTOs.Auth.LoginRequestDto>,
                DigitalWallet.Application.Validators.LoginRequestValidator>();

            services.AddTransient<
                FluentValidation.IValidator<DigitalWallet.Application.DTOs.Transfer.SendMoneyRequestDto>,
                DigitalWallet.Application.Validators.SendMoneyRequestValidator>();

            services.AddTransient<
                FluentValidation.IValidator<DigitalWallet.Application.DTOs.BillPayment.PayBillRequestDto>,
                DigitalWallet.Application.Validators.PayBillRequestValidator>();

            services.AddTransient<
                FluentValidation.IValidator<DigitalWallet.Application.DTOs.FakeBank.DepositRequestDto>,
                DigitalWallet.Application.Validators.DepositRequestValidator>();

            // ── 4.  Authorization Policies ────────────────────────────────────
            // The AdminController uses [Authorize(Policy = "AdminOnly")].
            // This policy requires the ClaimTypes.Role claim to contain "SuperAdmin"
            // OR "Support".  Adjust the allowed roles list as your RBAC model evolves.
            services.AddAuthorization(options =>
            {
                options.AddPolicy("AdminOnly", policy =>
                {
                    policy.RequireAuthenticatedUser();
                    policy.RequireClaim(
                        System.Security.Claims.ClaimTypes.Role,
                        "SuperAdmin", "Support");
                });
            });

            return services;
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Extensions\SwaggerExtensions.cs =====
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Swashbuckle.AspNetCore.Swagger;
using Swashbuckle.AspNetCore.SwaggerGen;
using Swashbuckle.AspNetCore.SwaggerUI;
using Microsoft.OpenApi.Models;

namespace DigitalWallet.API.Extensions
{
    /// <summary>
    /// Swagger / OpenAPI configuration helpers.
    /// Keeps Program.cs clean and makes it easy to tweak the generated docs
    /// independently of the rest of the startup sequence.
    /// </summary>
    public static class SwaggerExtensions
    {
        /// <summary>
        /// Configures the Swagger generator:
        ///   • Title, version, and description shown at the top of the Swagger UI page.
        ///   • A "Bearer" security definition so developers can paste their token once
        ///     and have it sent on every request.
        ///   • XML doc comments are included when the project is built with
        ///     &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;.
        /// </summary>
        public static IServiceCollection AddSwaggerDocumentation(this IServiceCollection services)
        {
            services.AddSwaggerGen(options =>
            {
                // ── Basic info ────────────────────────────────────────────────
                options.SwaggerDoc("v1", new OpenApiInfo
                {
                    Title = "DigitalWallet API",
                    Version = "v1",
                    Description = "RESTful API for the DigitalWallet graduation project. "
                                 + "Supports user registration/login, wallet management, "
                                 + "money transfers, bill payments, and admin operations.",
                    Contact = new OpenApiContact
                    {
                        Name = "Development Team",
                        Email = "dev@digitalwallet.local"
                    },
                    License = new OpenApiLicense { Name = "MIT" }
                });

                // ── Bearer token security scheme ─────────────────────────────
                // Tells Swagger UI to show an "Authorize" button that prepends
                // "Bearer <token>" to every request's Authorization header.
                options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
                {
                    Type = SecuritySchemeType.Http,
                    Scheme = "Bearer",
                    BearerFormat = "JWT",
                    Description = "Enter your token in the text box below.\r\n\r\n"
                                + "Example: <b>eyJhbGci...</b>"
                });

                // Apply the Bearer scheme globally so every endpoint shows the lock icon.
                // Endpoints marked [AllowAnonymous] will still accept unauthenticated calls;
                // this just ensures the header is sent when the token is provided.
                options.AddSecurityRequirement(new OpenApiSecurityRequirement
                {
                    {
                        new OpenApiSecurityScheme
                        {
                            Reference = new OpenApiReference
                            {
                                Type = ReferenceType.SecurityScheme,
                                Id   = "Bearer"
                            }
                        },
                        Array.Empty<string>()
                    }
                });

                // ── XML documentation comments ───────────────────────────────
                // Uncomment and set the correct path once GenerateDocumentationFile is enabled.
                // var xmlFile = Path.Combine(AppDomain.CurrentDomain.BaseDirectory,
                //     $"{Assembly.GetExecutingAssembly().GetName().Name}.xml");
                // if (File.Exists(xmlFile))
                //     options.IncludeXmlComments(xmlFile);

                // ── Avoid "duplicate schema" errors when two DTOs share a name ─
                options.UseFullyQualifiedSchemaNames();
            });

            return services;
        }

        /// <summary>
        /// Activates the Swagger middleware and its UI.
        /// Conditionally enabled: only runs when the environment is <b>Development</b>
        /// (controlled by the caller in Program.cs via <c>app.Environment.IsDevelopment()</c>).
        /// </summary>
        public static WebApplication UseSwaggerDocumentation(this WebApplication app)
        {
            app.UseSwagger(options =>
            {
                // Serve the spec at /swagger/v1/swagger.json (default)
                options.RoutePrefix = "swagger";
            });

            app.UseSwaggerUI(options =>
            {
                options.SwaggerEndpoint("/swagger/v1/swagger.json", "DigitalWallet API v1");
                options.RoutePrefix = "swagger"; // UI available at /swagger
                options.DocumentTitle = "DigitalWallet – Swagger UI";

                // Persist authorisation across page refreshes (token stays in the textbox)
                options.ConfigObject.AdditionalInterceptors = new Dictionary<string, object>
                {
                    ["persistAuthorization"] = true
                };
            });

            return app;
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Filters\AuthorizationFilter.cs =====
using DigitalWallet.Application.Common;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using System.Security.Claims;
using System.Web.Http.Filters;

namespace DigitalWallet.API.Filters
{
    // ─────────────────────────────────────────────────────────────────────────
    // 1.  Attribute  –  applied to controllers / actions that demand a specific
    //     role claim.  If no roles are supplied the attribute simply enforces
    //     authentication (same as [Authorize]).
    // ─────────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Declarative attribute that triggers <see cref="AuthorizationFilter"/> at run-time.
    ///
    /// Usage examples:
    ///   [RoleAuthorize]                        // authenticated only
    ///   [RoleAuthorize("SuperAdmin")]          // must have SuperAdmin role claim
    ///   [RoleAuthorize("SuperAdmin","Support")]// either role is acceptable
    /// </summary>
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = false)]
    public sealed class RoleAuthorizeAttribute : Attribute, IFilterFactory
    {
        /// <summary>Set of acceptable roles.  Empty means "any authenticated user".</summary>
        public string[] Roles { get; }

        public RoleAuthorizeAttribute(params string[] roles)
        {
            Roles = roles;
        }

        /// <summary>
        /// ASP.NET Core calls this to obtain the actual filter instance, injecting its dependencies.
        /// </summary>
        public bool IsReusable => true; // safe: the filter is stateless

        public IFilter CreateFilter(IServiceProvider serviceProvider)
        {
            return new AuthorizationFilter(
                Roles,
                serviceProvider.GetRequiredService<ILogger<AuthorizationFilter>>());
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    // 2.  Filter  –  the actual logic executed for every request that has the
    //     attribute applied.
    // ─────────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Checks that the request is authenticated AND (optionally) that the principal
    /// holds at least one of the roles specified by <see cref="RoleAuthorizeAttribute"/>.
    ///
    /// Response contract:
    ///   • Not authenticated          → 401  with ApiResponse error message
    ///   • Authenticated but no role  → 403  with ApiResponse error message
    ///   • All checks pass            → pipeline continues normally
    /// </summary>
    public class AuthorizationFilter : IActionFilter
    {
        private readonly string[] _roles;
        private readonly ILogger<AuthorizationFilter> _logger;

        public AuthorizationFilter(string[] roles, ILogger<AuthorizationFilter> logger)
        {
            _roles = roles;
            _logger = logger;
        }

        public void OnActionExecuting(ActionExecutingContext context)
        {
            var user = context.HttpContext.User;

            // ── 1. Authentication check ──────────────────────────────────────
            if (user == null || !user.Identity!.IsAuthenticated)
            {
                _logger.LogWarning("AuthorizationFilter: Unauthenticated request to {Path}.",
                    context.HttpContext.Request.Path);

                context.Result = new UnauthorizedObjectResult(
                    ApiResponse<object>.ErrorResponse("Authentication is required."));
                return;
            }

            // ── 2. Role check (skipped when no roles were specified) ──────────
            if (_roles.Length == 0)
                return; // attribute used as a pure authentication gate

            // The role claim key used throughout the project
            const string roleClaimType = ClaimTypes.Role;

            var userRoles = user.Claims
                .Where(c => c.Type == roleClaimType)
                .Select(c => c.Value)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            var hasRequiredRole = _roles.Any(r => userRoles.Contains(r));

            if (!hasRequiredRole)
            {
                var userId = user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "unknown";
                _logger.LogWarning(
                    "AuthorizationFilter: UserId {UserId} lacks required role(s) [{Roles}] for {Path}.",
                    userId,
                    string.Join(", ", _roles),
                    context.HttpContext.Request.Path);

                context.Result = new ForbiddenObjectResult(
                    ApiResponse<object>.ErrorResponse(
                        $"Access denied. Required role(s): {string.Join(", ", _roles)}."));
            }
        }

        public void OnActionExecuted(ActionExecutedContext context)
        {
            // No post-action logic needed
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Filters\ValidationFilter.cs =====
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using DigitalWallet.Application.Common;

namespace DigitalWallet.API.Filters
{
    /// <summary>
    /// Action filter that intercepts requests with ModelState errors
    /// (populated either by the default [ApiController] model-validation or by
    /// FluentValidation's model-validation integration) and returns a uniform
    /// 400 response shaped like <see cref="ApiResponse{T}"/>.
    ///
    /// This replaces the default ASP.NET Core error response so every validation
    /// failure across the entire API has the same JSON structure.
    ///
    /// How to register (one-time, in Program.cs or ServiceCollectionExtensions):
    ///   builder.Services.AddControllers(options =>
    ///       options.Filters.Add<ValidationFilter>());
    /// </summary>
    public class ValidationFilter : IActionFilter
    {
        private readonly ILogger<ValidationFilter> _logger;

        public ValidationFilter(ILogger<ValidationFilter> logger)
        {
            _logger = logger;
        }

        /// <summary>No-op; we only need the post-binding hook.</summary>
        public void OnActionExecuting(ActionExecutingContext context)
        {
            // Intentionally empty – see OnActionExecuted
        }

        /// <summary>No-op; validation is checked before the action runs.</summary>
        public void OnActionExecuted(ActionExecutedContext context)
        {
            // Intentionally empty
        }

        /// <summary>
        /// Runs before the action method is invoked.  If ModelState is invalid the action
        /// is short-circuited and a 400 <see cref="ApiResponse{object}"/> is returned.
        /// </summary>
        /// <remarks>
        /// We use the non-async overload because there is no I/O here; it is purely
        /// in-memory inspection of the ModelState dictionary.
        /// </remarks>
        public void OnActionExecuting(ActionExecutingContext context)
        {
            if (context.ModelState.IsValid)
                return; // nothing to do

            // ── Collect all error messages in a flat list ─────────────────────
            var errors = new List<string>();

            foreach (var kvp in context.ModelState)
            {
                if (kvp.Value == null) continue;

                foreach (var error in kvp.Value.Errors)
                {
                    // Prefer the developer-supplied message; fall back to the exception text
                    var message = !string.IsNullOrWhiteSpace(error.ErrorMessage)
                        ? error.ErrorMessage
                        : error.Exception?.Message ?? "Validation error";

                    // Prepend the property name when available so the client knows which field failed
                    if (!string.IsNullOrWhiteSpace(kvp.Key))
                        errors.Add($"{kvp.Key}: {message}");
                    else
                        errors.Add(message);
                }
            }

            _logger.LogWarning("Validation failed. Errors: [{Errors}]", string.Join("; ", errors));

            // ── Short-circuit: set the result and stop the pipeline ───────────
            context.Result = new BadRequestObjectResult(
                ApiResponse<object>.ErrorResponse(errors));
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Middleware\ExceptionHandlingMiddleware.cs =====
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using System.Text.Json;
using DigitalWallet.Application.Common;
using DigitalWallet.Domain.Exceptions;

namespace DigitalWallet.API.Middleware
{
    /// <summary>
    /// Global exception handler that sits at the top of the middleware pipeline.
    /// Catches any unhandled exception thrown by downstream middleware or controllers
    /// and converts it into a uniform JSON <see cref="ApiResponse{T}"/> so the client
    /// always receives a predictable error shape, even on 500 errors.
    ///
    /// Mapping table
    /// ─────────────────────────────────────────────────────────────
    /// Exception type                  │ HTTP status  │ Log level
    /// ─────────────────────────────────────────────────────────────
    /// UnauthorizedAccessException      │ 401          │ Warning
    /// DomainException (base)           │ 400          │ Warning
    ///   └─ InsufficientBalanceEx.      │ 400          │ Warning
    ///   └─ InvalidOtpException         │ 400          │ Warning
    ///   └─ InvalidTransferException    │ 400          │ Warning
    ///   └─ UserNotFoundException       │ 404          │ Warning
    ///   └─ WalletLimitExceededException│ 400          │ Warning
    /// ArgumentException                │ 400          │ Warning
    /// OperationCanceledException       │ 499 / 408    │ Info
    /// Exception (everything else)      │ 500          │ Error   (details hidden)
    /// ─────────────────────────────────────────────────────────────
    /// </summary>
    public class ExceptionHandlingMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<ExceptionHandlingMiddleware> _logger;

        public ExceptionHandlingMiddleware(RequestDelegate next, ILogger<ExceptionHandlingMiddleware> logger)
        {
            _next = next;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context, RequestDelegate next)
        {
            try
            {
                await _next(context);
            }
            catch (Exception ex)
            {
                await HandleExceptionAsync(context, ex);
            }
        }

        private async Task HandleExceptionAsync(HttpContext context, Exception exception)
        {
            int statusCode;
            string message;
            string logCategory; // used only for structured logging

            switch (exception)
            {
                // ── 401  Unauthorized ─────────────────────────────────────────
                case UnauthorizedAccessException:
                    statusCode = StatusCodes.Status401Unauthorized;
                    message = "Unauthorized access.";
                    logCategory = "Unauthorized";
                    _logger.LogWarning(exception, "[{Category}] {Message}", logCategory, message);
                    break;

                // ── 404  Not Found (specific domain exceptions) ──────────────
                case UserNotFoundException:
                    statusCode = StatusCodes.Status404NotFound;
                    message = exception.Message;
                    logCategory = "NotFound";
                    _logger.LogWarning(exception, "[{Category}] {Message}", logCategory, message);
                    break;

                // ── 400  Business-rule violations (domain exceptions) ─────────
                case InsufficientBalanceException
                    or InvalidOtpException
                    or InvalidTransferException
                    or WalletLimitExceededException:
                    statusCode = StatusCodes.Status400BadRequest;
                    message = exception.Message;
                    logCategory = "BusinessRule";
                    _logger.LogWarning(exception, "[{Category}] {Message}", logCategory, message);
                    break;

                // ── 400  Generic domain exception base (catch-all for domain) ─
                case DomainException:
                    statusCode = StatusCodes.Status400BadRequest;
                    message = exception.Message;
                    logCategory = "DomainError";
                    _logger.LogWarning(exception, "[{Category}] {Message}", logCategory, message);
                    break;

                // ── 400  Bad argument (programming / input errors) ───────────
                case ArgumentException:
                    statusCode = StatusCodes.Status400BadRequest;
                    message = exception.Message;
                    logCategory = "ArgumentError";
                    _logger.LogWarning(exception, "[{Category}] {Message}", logCategory, message);
                    break;

                // ── 408  Request timeout (client cancelled) ───────────────────
                case OperationCanceledException:
                    statusCode = StatusCodes.Status408RequestTimeout;
                    message = "The request was cancelled or timed out.";
                    logCategory = "Cancelled";
                    _logger.LogInformation("[{Category}] {Message}", logCategory, message);
                    break;

                // ── 500  Unhandled – hide internals from the client ──────────
                default:
                    statusCode = StatusCodes.Status500InternalServerError;
                    message = "An unexpected error occurred. Please try again later.";
                    logCategory = "Unhandled";
                    _logger.LogError(exception, "[{Category}] Unhandled exception.", logCategory);
                    break;
            }

            // Prevent double-writing if the response has already started (e.g. streaming)
            if (context.Response.HasStarted)
            {
                _logger.LogCritical("[ExceptionMiddleware] Response already started; cannot write error body.");
                return;
            }

            // ── Write the uniform JSON error response ─────────────────────────
            context.Response.StatusCode = statusCode;
            context.Response.ContentType = "application/json";

            var response = ApiResponse<object>.ErrorResponse(message);

            var jsonOptions = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteGetterOnly = true
            };

            await context.Response.WriteAsJsonAsync(response, jsonOptions);
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Middleware\JwtMiddleware.cs =====
using System.Security.Claims;
using System.Text;

namespace DigitalWallet.API.Middleware
{
    /// <summary>
    /// Custom JWT middleware that complements (or replaces) the default ASP.NET Core
    /// JwtBearer authentication scheme.
    ///
    /// Why it exists:
    ///   The AuthService currently issues a simplified Base64 token of the form
    ///   "{UserId}:{Ticks}".  Until a proper JWT library (e.g. Microsoft.AspNetCore.Authentication.JwtBearer)
    ///   with real signing is wired up, this middleware decodes that token and populates
    ///   HttpContext.User so that [Authorize] and ClaimsPrincipal work correctly.
    ///
    /// Token lifecycle:
    ///   1. Extract the raw token from the Authorization header (Bearer scheme).
    ///   2. Decode Base64 → "{UserId}:{Ticks}".
    ///   3. Parse and validate UserId (must be a valid GUID) and Ticks (must not be in the future,
    ///      and must be within the configured expiry window – default 24 h).
    ///   4. Build a ClaimsPrincipal with NameIdentifier = UserId.
    ///   5. Set HttpContext.User.
    ///
    /// Migration note:
    ///   Once AuthService emits real JWT tokens signed with a secret key, replace the
    ///   Decode/Validate logic below with standard AddJwtBearer() configuration and remove
    ///   this middleware entirely.
    /// </summary>
    public class JwtMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<JwtMiddleware> _logger;

        /// <summary>Token lifetime.  Must match the expiry set in AuthService.RegisterAsync / LoginAsync.</summary>
        private static readonly TimeSpan TokenLifetime = TimeSpan.FromHours(24);

        public JwtMiddleware(RequestDelegate next, ILogger<JwtMiddleware> logger)
        {
            _next = next;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var token = ExtractToken(context);

            if (!string.IsNullOrWhiteSpace(token))
            {
                var principal = ValidateAndBuildPrincipal(token);

                if (principal != null)
                {
                    context.User = principal;
                    _logger.LogDebug("JWT middleware: Authenticated UserId {UserId}.",
                        principal.FindFirst(ClaimTypes.NameIdentifier)?.Value);
                }
                else
                {
                    _logger.LogWarning("JWT middleware: Token present but validation failed.");
                }
            }

            await _next(context);
        }

        // ───────────────────────────── private helpers ─────────────────────────

        /// <summary>
        /// Pulls the raw token string out of the Authorization: Bearer header.
        /// Returns null when the header is absent or does not follow the Bearer scheme.
        /// </summary>
        private static string? ExtractToken(HttpContext context)
        {
            var authHeader = context.Request.Headers.Authorization;

            if (string.IsNullOrWhiteSpace(authHeader))
                return null;

            // Expected format: "Bearer <token>"
            var parts = authHeader.Split(' ', 2, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length != 2 || !parts[0].Equals("Bearer", StringComparison.OrdinalIgnoreCase))
                return null;

            return parts[1];
        }

        /// <summary>
        /// Decodes the simplified token and returns a ClaimsPrincipal on success, or null on any failure.
        /// Failures include: malformed Base64, non-GUID UserId, missing Ticks, expired token, or future-dated token.
        /// </summary>
        private ClaimsPrincipal? ValidateAndBuildPrincipal(string token)
        {
            try
            {
                // ── 1. Decode ─────────────────────────────────────────────────
                var decoded = Encoding.UTF8.GetString(Convert.FromBase64String(token));

                // Expected decoded format: "{Guid}:{Ticks}"
                var colonIndex = decoded.IndexOf(':');
                if (colonIndex < 0)
                {
                    _logger.LogWarning("JWT middleware: Decoded token missing ':' separator.");
                    return null;
                }

                var userIdRaw = decoded[..colonIndex];
                var ticksRaw = decoded[(colonIndex + 1)..];

                // ── 2. Validate UserId ────────────────────────────────────────
                if (!Guid.TryParse(userIdRaw, out var userId))
                {
                    _logger.LogWarning("JWT middleware: UserId is not a valid GUID.");
                    return null;
                }

                // ── 3. Validate Ticks / expiry ────────────────────────────────
                if (!long.TryParse(ticksRaw, out var ticks))
                {
                    _logger.LogWarning("JWT middleware: Ticks value is not a valid long.");
                    return null;
                }

                var issuedAt = new DateTime(ticks, DateTimeKind.Utc);
                var now = DateTime.UtcNow;

                // Reject tokens issued in the future (clock skew tolerance: 5 minutes)
                if (issuedAt > now.AddMinutes(5))
                {
                    _logger.LogWarning("JWT middleware: Token issued in the future. IssuedAt: {IssuedAt}", issuedAt);
                    return null;
                }

                // Reject tokens past their lifetime
                if (now > issuedAt.Add(TokenLifetime))
                {
                    _logger.LogWarning("JWT middleware: Token expired. IssuedAt: {IssuedAt}", issuedAt);
                    return null;
                }

                // ── 4. Build ClaimsPrincipal ──────────────────────────────────
                var claims = new[]
                {
                    new Claim(ClaimTypes.NameIdentifier, userId.ToString()),
                    new Claim("iat", issuedAt.ToString("O")) // issued-at for debugging
                };

                var identity = new ClaimsIdentity(claims, "SimplifiedJwt");
                var principal = new ClaimsPrincipal(identity);

                return principal;
            }
            catch (Exception ex)
            {
                // Covers FormatException from Base64, OverflowException from DateTime, etc.
                _logger.LogWarning(ex, "JWT middleware: Exception during token validation.");
                return null;
            }
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Middleware\RequestLoggingMiddleware.cs =====
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using System.Diagnostics;

namespace DigitalWallet.API.Middleware
{
    /// <summary>
    /// Logs every inbound HTTP request and its corresponding response in a structured format.
    ///
    /// Captured fields per request:
    ///   • CorrelationId  – unique per request (from X-Correlation-Id header, or auto-generated)
    ///   • Method / Path  – HTTP verb and URL path
    ///   • StatusCode     – HTTP status of the response
    ///   • ElapsedMs      – end-to-end processing time in milliseconds
    ///   • ClientIp       – remote address (first value of X-Forwarded-For when behind a reverse proxy)
    ///   • UserId         – extracted from the JWT claim after authentication (if present)
    ///
    /// The middleware also injects the correlation ID back into every response via the
    /// X-Correlation-Id header so that client-side code can reference it in bug reports.
    /// </summary>
    public class RequestLoggingMiddleware
    {
        private const string CorrelationIdHeader = "X-Correlation-Id";
        private const string UserIdClaimType = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier";

        private readonly RequestDelegate _next;
        private readonly ILogger<RequestLoggingMiddleware> _logger;

        public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger)
        {
            _next = next;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            // ── Resolve or generate correlation ID ────────────────────────────
            var correlationId = context.Request.Headers.TryGetValue(CorrelationIdHeader, out var existing)
                ? existing.ToString()
                : Guid.NewGuid().ToString();

            // Attach to response so the client can correlate errors back to server logs
            context.Response.OnStarted(() =>
            {
                context.Response.Headers.Append(CorrelationIdHeader, correlationId);
                return Task.CompletedTask;
            });

            // ── Build the structured log scope ────────────────────────────────
            // Everything inside the scope automatically includes these properties
            using (_logger.BeginScope(new Dictionary<string, object?>
            {
                ["CorrelationId"] = correlationId,
                ["ClientIp"] = GetClientIp(context)
            }))
            {
                _logger.LogInformation(
                    "Request  START  | {Method} {Path}",
                    context.Request.Method,
                    context.Request.Path);

                var stopwatch = Stopwatch.StartNew();

                // ── Call the rest of the pipeline ────────────────────────────
                await _next(context);

                stopwatch.Stop();

                // ── Extract UserId after authentication has run ────────────
                var userId = context.User?.FindFirst(UserIdClaimType)?.Value ?? "anonymous";

                // ── Choose log level based on status code ───────────────────
                // 5xx = Error, 4xx = Warning, 2xx/3xx = Information
                var logLevel = context.Response.StatusCode >= 500 ? LogLevel.Error
                             : context.Response.StatusCode >= 400 ? LogLevel.Warning
                             : LogLevel.Information;

                _logger.Log(logLevel,
                    "Request  END    | {Method} {Path} | Status: {StatusCode} | Elapsed: {ElapsedMs}ms | UserId: {UserId}",
                    context.Request.Method,
                    context.Request.Path,
                    context.Response.StatusCode,
                    stopwatch.ElapsedMilliseconds,
                    userId);
            }
        }

        /// <summary>
        /// Returns the real client IP.
        /// When behind a load balancer / reverse proxy the true IP is usually in X-Forwarded-For.
        /// Falls back to RemoteIpAddress.
        /// </summary>
        private static string? GetClientIp(HttpContext context)
        {
            // X-Forwarded-For may contain multiple comma-separated IPs; the first is the original client.
            var forwardedFor = context.Request.Headers.TryGetValue("X-Forwarded-For", out var xff)
                ? xff.ToString().Split(',')[0].Trim()
                : null;

            return forwardedFor ?? context.Connection.RemoteIpAddress?.ToString();
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Properties\launchSettings.json =====
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:47840",
      "sslPort": 44310
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "http://localhost:5074",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:7182;http://localhost:5074",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\appsettings.Development.json =====
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore.Database.Command": "Information",
      "DigitalWallet.API": "Debug",
      "DigitalWallet.Application": "Debug"
    }
  },

  "Jwt": {
    "SecretKey": "dev-secret-key-not-for-production-use-only-32ch",
    "Issuer": "DigitalWallet.API.Dev",
    "Audience": "DigitalWallet.Clients.Dev",
    "ExpirationHours": 24
  },

  "Cors": {
    "AllowedOrigins": [
      "http://localhost:3000",
      "http://localhost:8080",
      "http://localhost:5074",
      "https://localhost:7182"
    ]
  },

  "FakeBank": {
    "ProcessingDelaySeconds": 2,
    "MaxDepositAmount": 100000,
    "MaxWithdrawAmount": 100000
  },

  "Otp": {
    "ExpirationMinutes": 5,
    "MaxRetries": 5
  }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\appsettings.json =====
{
  "Logging": {
    "LogLevel": {
      "Default": "Warning",
      "Microsoft.AspNetCore": "Warning",
      "DigitalWallet.API": "Information",
      "DigitalWallet.Application": "Information"
    }
  },
  "AllowedHosts": "*",

  "Jwt": {
    "SecretKey": "aGSwVVVmnZD8os5CqZZyH3byKa6FpwxJ7Kw6lemR5Kg=",
    "Issuer": "DigitalWallet.API",
    "Audience": "DigitalWallet.Clients",
    "ExpirationHours": 24
  },

  "Cors": {
    "AllowedOrigins": [
      "http://localhost:3000",
      "http://localhost:8080"
    ]
  },

  "FakeBank": {
    "ProcessingDelaySeconds": 5,
    "MaxDepositAmount": 100000,
    "MaxWithdrawAmount": 100000
  },

  "Otp": {
    "ExpirationMinutes": 5,
    "MaxRetries": 3
  }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\DigitalWallet.API.csproj =====
<Project Sdk="Microsoft.NET.Sdk.Web">

	<PropertyGroup>
		<TargetFramework>net8.0</TargetFramework>
		<Nullable>enable</Nullable>
		<ImplicitUsings>enable</ImplicitUsings>
		<!-- Enable XML doc comments for Swagger; suppress missing-doc warnings -->
		<GenerateDocumentationFile>true</GenerateDocumentationFile>
		<NoWarn>$(NoWarn);1591</NoWarn>
	</PropertyGroup>

	<!-- â”€â”€ NuGet Packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
	<ItemGroup>
		<!-- Swagger / OpenAPI -->
		<PackageReference Include="Microsoft.AspNet.WebApi.Core" Version="5.3.0" />

		<!-- <PackageReference Include="Swashbuckle.AspNetCore" Version="6.6.2" />	
		<PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />
		<PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />  -->

		<PackageReference Include="AutoMapper" Version="12.0.1" />
		<PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" Version="12.0.1" />
		<PackageReference Include="FluentValidation" Version="11.11.0" />
		<PackageReference Include="FluentValidation.AspNetCore" Version="11.3.1" />
	</ItemGroup>

	<!-- â”€â”€ Project References â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
	<ItemGroup>
		<ProjectReference Include="..\DigitalWallet.Application\DigitalWallet.Application.csproj" />
		<ProjectReference Include="..\DigitalWallet.Infrastructure\DigitalWallet.Infrastructure.csproj" />
		<ProjectReference Include="..\DigitalWallet.Domain\DigitalWallet.Domain.csproj" />
	</ItemGroup>

  <ItemGroup>
    <Folder Include="Controllers\" />
  </ItemGroup>

</Project>

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.API\Program.cs =====
using DigitalWallet.API.Extensions;
using DigitalWallet.API.Filters;

namespace DigitalWallet.API
{
    public class Program
    {
        public static void Main(string[] args)
        {
            var builder = WebApplication.CreateBuilder(args);

            // ── 1.  Configuration & Logging ─────────────────────────────────
            // appsettings.json and appsettings.{Environment}.json are loaded
            // automatically by CreateBuilder.  Console logging is the default
            // sink; swap for Serilog / NLog as needed.
            builder.Logging.AddConsole();

            // ── 2.  CORS ────────────────────────────────────────────────────
            // Read allowed origins from config so the front-end can call the API
            // without CORS errors during local development.
            builder.Services.AddCors(options =>
            {
                var origins = builder.Configuration
                    .GetSection("Cors:AllowedOrigins")
                    .Get<string[]>()
                    ?? Array.Empty<string>();

                options.AddDefaultPolicy(policy =>
                {
                    policy
                        .WithOrigins(origins)
                        .AllowAnyHeader()
                        .AllowAnyMethod();
                });
            });

            // ── 3.  Controllers + Filters ───────────────────────────────────
            // ValidationFilter is registered globally so every controller action
            // automatically returns a uniform 400 when ModelState is invalid.
            builder.Services.AddControllers(options =>
            {
                options.Filters.Add<ValidationFilter>();
            });

            // ── 4.  Swagger / OpenAPI ───────────────────────────────────────
            builder.Services.AddEndpointsApiExplorer();
            builder.Services.AddSwaggerDocumentation();

            // ── 5.  Application & Infrastructure Services ──────────────────
            // Wires up every scoped service, AutoMapper, FluentValidation
            // validators, and the "AdminOnly" authorization policy.
            builder.Services.AddApplicationServices();

            // ── 6.  Build the WebApplication ────────────────────────────────
            var app = builder.Build();

            // ── 7.  Middleware pipeline (order is critical) ─────────────────
            //
            //   ┌─ ExceptionHandlingMiddleware   ← outermost: catches everything
            //   │  ┌─ RequestLoggingMiddleware   ← logs request start/end + timing
            //   │  │  ┌─ JwtMiddleware           ← populates HttpContext.User
            //   │  │  │  ┌─ CORS                 ← adds Access-Control-* headers
            //   │  │  │  │  ┌─ HTTPS Redirect    ← 301 http → https
            //   │  │  │  │  │  ┌─ Authorization  ← evaluates [Authorize] policies
            //   │  │  │  │  │  │  ┌─ Controllers ← action methods
            //
            app.UseDigitalWalletMiddleware();  // Exception → Logging → Jwt

            app.UseCors();
            app.UseHttpsRedirection();

            // Authorization must come AFTER JwtMiddleware has set HttpContext.User
            app.UseAuthorization();

            // ── 8.  Swagger UI (Development only) ──────────────────────────
            if (app.Environment.IsDevelopment())
            {
                app.UseSwaggerDocumentation();
            }

            // ── 9.  Route controllers ───────────────────────────────────────
            app.MapControllers();

            // ── 10. Health-check endpoint ───────────────────────────────────
            // Quick smoke-test: GET /health → 200 OK
            app.MapGet("/health", () => new { Status = "Healthy", Timestamp = DateTime.UtcNow });

            app.Run();
        }
    }
}

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Common\ApiResponse.cs =====
namespace DigitalWallet.Application.Common
{
    public class ApiResponse<T>
    {
        public bool Success { get; set; }
        public T? Data { get; set; }
        public string? Message { get; set; }
        public List<string>? Errors { get; set; }
        public DateTime Timestamp { get; set; }

        public ApiResponse()
        {
            Timestamp = DateTime.UtcNow;
        }

        public static ApiResponse<T> SuccessResponse(T data, string? message = null)
        {
            return new ApiResponse<T>
            {
                Success = true,
                Data = data,
                Message = message ?? "Operation successful"
            };
        }

        public static ApiResponse<T> ErrorResponse(string error)
        {
            return new ApiResponse<T>
            {
                Success = false,
                Errors = new List<string> { error }
            };
        }

        public static ApiResponse<T> ErrorResponse(List<string> errors)
        {
            return new ApiResponse<T>
            {
                Success = false,
                Errors = errors
            };
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Common\PaginatedResult.cs =====
namespace DigitalWallet.Application.Common
{
    public class PaginatedResult<T>
    {
        public List<T> Items { get; set; } = new();
        public int PageNumber { get; set; }
        public int PageSize { get; set; }
        public int TotalPages { get; set; }
        public int TotalCount { get; set; }
        public bool HasPrevious => PageNumber > 1;
        public bool HasNext => PageNumber < TotalPages;

        public PaginatedResult(List<T> items, int count, int pageNumber, int pageSize)
        {
            Items = items;
            TotalCount = count;
            PageNumber = pageNumber;
            PageSize = pageSize;
            TotalPages = (int)Math.Ceiling(count / (double)pageSize);
        }

        public static PaginatedResult<T> Create(List<T> items, int count, int pageNumber, int pageSize)
        {
            return new PaginatedResult<T>(items, count, pageNumber, pageSize);
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Common\ServiceResult.cs =====
namespace DigitalWallet.Application.Common
{
    public class ServiceResult<T>
    {
        public bool IsSuccess { get; set; }
        public T? Data { get; set; }
        public string? Message { get; set; }
        public List<string>? Errors { get; set; }

        public static ServiceResult<T> Success(T data, string? message = null)
        {
            return new ServiceResult<T>
            {
                IsSuccess = true,
                Data = data,
                Message = message
            };
        }

        public static ServiceResult<T> Failure(string error)
        {
            return new ServiceResult<T>
            {
                IsSuccess = false,
                Errors = new List<string> { error }
            };
        }

        public static ServiceResult<T> Failure(List<string> errors)
        {
            return new ServiceResult<T>
            {
                IsSuccess = false,
                Errors = errors
            };
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Admin\FraudLogDto.cs =====
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.DTOs.Admin
{
    public class FraudLogDto
    {
        public Guid Id { get; set; }
        public Guid UserId { get; set; }
        public string UserName { get; set; } = string.Empty;
        public FraudType Type { get; set; }
        public string? Description { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Admin\UserManagementDto.cs =====
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.DTOs.Admin
{
    public class UserManagementDto
    {
        public Guid Id { get; set; }
        public string FullName { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;
        public string PhoneNumber { get; set; } = string.Empty;
        public KycLevel KycLevel { get; set; }
        public UserStatus Status { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime? LastLoginAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Admin\WalletManagementDto.cs =====
namespace DigitalWallet.Application.DTOs.Admin
{
    public class WalletManagementDto
    {
        public Guid Id { get; set; }
        public Guid UserId { get; set; }
        public string UserName { get; set; } = string.Empty;
        public string UserEmail { get; set; } = string.Empty;
        public string CurrencyCode { get; set; } = string.Empty;
        public decimal Balance { get; set; }
        public decimal DailyLimit { get; set; }
        public decimal MonthlyLimit { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Auth\LoginRequestDto.cs =====
namespace DigitalWallet.Application.DTOs.Auth
{
    public class LoginRequestDto
    {
        public string EmailOrPhone { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Auth\LoginResponseDto.cs =====
namespace DigitalWallet.Application.DTOs.Auth
{
    public class LoginResponseDto
    {
        public string Token { get; set; } = string.Empty;
        public string RefreshToken { get; set; } = string.Empty;
        public DateTime ExpiresAt { get; set; }
        public Guid UserId { get; set; }
        public string FullName { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;
        public bool RequiresOtp { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Auth\RefreshTokenRequestDto.cs =====
namespace DigitalWallet.Application.DTOs.Auth
{
    public class RefreshTokenRequestDto
    {
        public string RefreshToken { get; set; } = string.Empty;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Auth\RegisterRequestDto.cs =====
namespace DigitalWallet.Application.DTOs.Auth
{
    public class RegisterRequestDto
    {
        public string FullName { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;
        public string PhoneNumber { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
        public string ConfirmPassword { get; set; } = string.Empty;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Auth\UserDto.cs =====
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.DTOs.Auth
{
    public class UserDto
    {
        public Guid Id { get; set; }
        public string FullName { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;
        public string PhoneNumber { get; set; } = string.Empty;
        public string KycLevel { get; set; } = string.Empty;
        public string Status { get; set; } = string.Empty;
        public DateTime? LastLoginAt { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Auth\VerifyOtpRequestDto.cs =====
namespace DigitalWallet.Application.DTOs.Auth
{
    public class VerifyOtpRequestDto
    {
        public Guid UserId { get; set; }
        public string Code { get; set; } = string.Empty;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\BillPayment\BillerDto.cs =====
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.DTOs.BillPayment
{
    public class BillerDto
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public BillCategory Category { get; set; }
        public bool IsActive { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\BillPayment\BillPaymentDto.cs =====
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.DTOs.BillPayment
{
    public class BillPaymentDto
    {
        public Guid Id { get; set; }
        public Guid UserId { get; set; }
        public Guid WalletId { get; set; }
        public Guid BillerId { get; set; }
        public string BillerName { get; set; } = string.Empty;
        public decimal Amount { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
        public TransactionStatus Status { get; set; }
        public string? ReceiptPath { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\BillPayment\PayBillRequestDto.cs =====
namespace DigitalWallet.Application.DTOs.BillPayment
{
    public class PayBillRequestDto
    {
        public Guid WalletId { get; set; }
        public Guid BillerId { get; set; }
        public decimal Amount { get; set; }
        public string OtpCode { get; set; } = string.Empty;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\FakeBank\DepositRequestDto.cs =====
namespace DigitalWallet.Application.DTOs.FakeBank
{
    public class DepositRequestDto
    {
        public Guid UserId { get; set; }
        public decimal Amount { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\FakeBank\FakeBankTransactionDto.cs =====
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.DTOs.FakeBank
{
    public class FakeBankTransactionDto
    {
        public Guid Id { get; set; }
        public Guid UserId { get; set; }
        public decimal Amount { get; set; }
        public string Type { get; set; } = string.Empty;
        public TransactionStatus Status { get; set; }
        public int DelaySeconds { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\FakeBank\WithdrawRequestDto.cs =====
namespace DigitalWallet.Application.DTOs.FakeBank
{
    public class WithdrawRequestDto
    {
        public Guid UserId { get; set; }
        public decimal Amount { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\MoneyRequest\AcceptRejectRequestDto.cs =====
namespace DigitalWallet.Application.DTOs.MoneyRequest
{
    public class AcceptRejectRequestDto
    {
        public Guid RequestId { get; set; }
        public bool Accept { get; set; }
        public string? OtpCode { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\MoneyRequest\CreateMoneyRequestDto.cs =====
namespace DigitalWallet.Application.DTOs.MoneyRequest
{
    public class CreateMoneyRequestDto
    {
        public string ToUserPhoneOrEmail { get; set; } = string.Empty;
        public decimal Amount { get; set; }
        public string CurrencyCode { get; set; } = "EGP";
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\MoneyRequest\MoneyRequestDto.cs =====
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.DTOs.MoneyRequest
{
    public class MoneyRequestDto
    {
        public Guid Id { get; set; }
        public Guid FromUserId { get; set; }
        public string FromUserName { get; set; } = string.Empty;
        public Guid ToUserId { get; set; }
        public string ToUserName { get; set; } = string.Empty;
        public decimal Amount { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
        public MoneyRequestStatus Status { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Notification\NotificationDto.cs =====
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.DTOs.Notification
{
    public class NotificationDto
    {
        public Guid Id { get; set; }
        public string Title { get; set; } = string.Empty;
        public string Body { get; set; } = string.Empty;
        public NotificationType Type { get; set; }
        public bool IsRead { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Transaction\TransactionDto.cs =====
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.DTOs.Transaction
{
    public class TransactionDto
    {
        public Guid Id { get; set; }
        public Guid WalletId { get; set; }
        public TransactionType Type { get; set; }
        public decimal Amount { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
        public TransactionStatus Status { get; set; }
        public string? Description { get; set; }
        public string? Reference { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Transaction\TransactionFilterDto.cs =====
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.DTOs.Transaction
{
    public class TransactionFilterDto
    {
        public Guid? WalletId { get; set; }
        public TransactionType? Type { get; set; }
        public TransactionStatus? Status { get; set; }
        public DateTime? StartDate { get; set; }
        public DateTime? EndDate { get; set; }
        public decimal? MinAmount { get; set; }
        public decimal? MaxAmount { get; set; }
        public int PageNumber { get; set; } = 1;
        public int PageSize { get; set; } = 20;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Transaction\TransactionHistoryDto.cs =====
namespace DigitalWallet.Application.DTOs.Transaction
{
    public class TransactionHistoryDto
    {
        public Guid Id { get; set; }
        public Guid WalletId { get; set; }
        public string Type { get; set; } = string.Empty;
        public decimal Amount { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
        public string Status { get; set; } = string.Empty;
        public string? Description { get; set; }
        public string? Reference { get; set; }
        public DateTime CreatedAt { get; set; }

        // Additional properties for history display
        public string DisplayAmount => Amount >= 0 ? $"+{Amount:N2}" : $"{Amount:N2}";
        public string TransactionTypeDisplay => Type switch
        {
            "Transfer" => "Money Transfer",
            "Bill" => "Bill Payment",
            "Deposit" => "Deposit from Bank",
            "Withdraw" => "Withdrawal to Bank",
            "Refund" => "Refund",
            _ => Type
        };
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Transfer\SendMoneyRequestDto.cs =====
namespace DigitalWallet.Application.DTOs.Transfer
{
    public class SendMoneyRequestDto
    {
        public Guid SenderWalletId { get; set; }
        public string ReceiverPhoneOrEmail { get; set; } = string.Empty;
        public decimal Amount { get; set; }
        public string? Description { get; set; }
        public string OtpCode { get; set; } = string.Empty;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Transfer\TransferDto.cs =====
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.DTOs.Transfer
{
    public class TransferDto
    {
        public Guid Id { get; set; }
        public Guid SenderWalletId { get; set; }
        public Guid ReceiverWalletId { get; set; }
        public decimal Amount { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
        public TransactionStatus Status { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Transfer\TransferResponseDto.cs =====
namespace DigitalWallet.Application.DTOs.Transfer
{
    public class TransferResponseDto
    {
        public Guid TransferId { get; set; }
        public string ReceiverName { get; set; } = string.Empty;
        public decimal Amount { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
        public string Status { get; set; } = string.Empty;
        public DateTime TransferredAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Wallet\CreateWalletRequestDto.cs =====
namespace DigitalWallet.Application.DTOs.Wallet
{
    public class CreateWalletRequestDto
    {
        public Guid UserId { get; set; }
        public string CurrencyCode { get; set; } = "EGP";
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Wallet\WalletBalanceDto.cs =====
namespace DigitalWallet.Application.DTOs.Wallet
{
    public class WalletBalanceDto
    {
        public Guid WalletId { get; set; }
        public decimal Balance { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DTOs\Wallet\WalletDto.cs =====
namespace DigitalWallet.Application.DTOs.Wallet
{
    public class WalletDto
    {
        public Guid Id { get; set; }
        public Guid UserId { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
        public decimal Balance { get; set; }
        public decimal DailyLimit { get; set; }
        public decimal MonthlyLimit { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Helpers\JwtTokenGenerator.cs =====
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Microsoft.IdentityModel.Tokens;
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Helpers
{
    public class JwtTokenGenerator
    {
        private readonly string _secretKey;
        private readonly string _issuer;
        private readonly string _audience;
        private readonly int _expirationHours;

        public JwtTokenGenerator(
            string secretKey,
            string issuer = "DigitalWallet",
            string audience = "DigitalWalletUsers",
            int expirationHours = 24)
        {
            if (string.IsNullOrEmpty(secretKey) || secretKey.Length < 32)
                throw new ArgumentException("Secret key must be at least 32 characters", nameof(secretKey));

            _secretKey = secretKey;
            _issuer = issuer;
            _audience = audience;
            _expirationHours = expirationHours;
        }

        /// <summary>
        /// Generates a JWT token for a user
        /// </summary>
        public string GenerateToken(User user)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes(_secretKey);

            var claims = new List<Claim>
            {
                new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
                new Claim(ClaimTypes.Email, user.Email),
                new Claim(ClaimTypes.Name, user.FullName),
                new Claim("phone", user.PhoneNumber),
                new Claim("kycLevel", user.KycLevel.ToString()),
                new Claim("status", user.Status.ToString())
            };

            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(claims),
                Expires = DateTime.UtcNow.AddHours(_expirationHours),
                Issuer = _issuer,
                Audience = _audience,
                SigningCredentials = new SigningCredentials(
                    new SymmetricSecurityKey(key),
                    SecurityAlgorithms.HmacSha256Signature)
            };

            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);
        }

        /// <summary>
        /// Generates a JWT token for an admin user
        /// </summary>
        public string GenerateAdminToken(AdminUser admin)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes(_secretKey);

            var claims = new List<Claim>
            {
                new Claim(ClaimTypes.NameIdentifier, admin.Id.ToString()),
                new Claim(ClaimTypes.Email, admin.Email),
                new Claim(ClaimTypes.Name, admin.FullName),
                new Claim(ClaimTypes.Role, admin.Role.ToString()),
                new Claim("isAdmin", "true")
            };

            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(claims),
                Expires = DateTime.UtcNow.AddHours(_expirationHours),
                Issuer = _issuer,
                Audience = _audience,
                SigningCredentials = new SigningCredentials(
                    new SymmetricSecurityKey(key),
                    SecurityAlgorithms.HmacSha256Signature)
            };

            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);
        }

        /// <summary>
        /// Validates a JWT token and returns the claims principal
        /// </summary>
        public ClaimsPrincipal? ValidateToken(string token)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes(_secretKey);

            try
            {
                var validationParameters = new TokenValidationParameters
                {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(key),
                    ValidateIssuer = true,
                    ValidIssuer = _issuer,
                    ValidateAudience = true,
                    ValidAudience = _audience,
                    ValidateLifetime = true,
                    ClockSkew = TimeSpan.Zero
                };

                var principal = tokenHandler.ValidateToken(token, validationParameters, out _);
                return principal;
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Extracts user ID from token
        /// </summary>
        public Guid? GetUserIdFromToken(string token)
        {
            var principal = ValidateToken(token);
            var userIdClaim = principal?.FindFirst(ClaimTypes.NameIdentifier);

            if (userIdClaim != null && Guid.TryParse(userIdClaim.Value, out var userId))
                return userId;

            return null;
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Helpers\OtpGenerator.cs =====
using System.Security.Cryptography;

namespace DigitalWallet.Application.Helpers
{
    public static class OtpGenerator
    {
        /// <summary>
        /// Generates a random 6-digit OTP code
        /// </summary>
        public static string GenerateOtpCode(int length = 6)
        {
            if (length < 4 || length > 10)
                throw new ArgumentException("OTP length must be between 4 and 10", nameof(length));

            using (var rng = RandomNumberGenerator.Create())
            {
                var bytes = new byte[4];
                rng.GetBytes(bytes);
                var randomNumber = BitConverter.ToUInt32(bytes, 0);

                var maxValue = (int)Math.Pow(10, length);
                var otp = randomNumber % maxValue;

                return otp.ToString($"D{length}");
            }
        }

        /// <summary>
        /// Generates a more secure numeric OTP
        /// </summary>
        public static string GenerateSecureOtp(int length = 6)
        {
            var random = new Random();
            var min = (int)Math.Pow(10, length - 1);
            var max = (int)Math.Pow(10, length) - 1;
            return random.Next(min, max).ToString();
        }

        /// <summary>
        /// Generates an alphanumeric OTP
        /// </summary>
        public static string GenerateAlphanumericOtp(int length = 8)
        {
            const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            var random = new Random();
            return new string(Enumerable.Repeat(chars, length)
                .Select(s => s[random.Next(s.Length)]).ToArray());
        }

        /// <summary>
        /// Generates a random account number for fake bank
        /// </summary>
        public static string GenerateAccountNumber()
        {
            var random = new Random();
            return $"FBA{random.Next(10000000, 99999999)}";
        }

        /// <summary>
        /// Generates a refresh token
        /// </summary>
        public static string GenerateRefreshToken()
        {
            var randomBytes = new byte[32];
            using (var rng = RandomNumberGenerator.Create())
            {
                rng.GetBytes(randomBytes);
            }
            return Convert.ToBase64String(randomBytes);
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Helpers\PasswordHasher.cs =====
using System.Security.Cryptography;
using System.Text;

namespace DigitalWallet.Application.Helpers
{
    public static class PasswordHasher
    {
        /// <summary>
        /// Generates a random salt for password hashing
        /// </summary>
        public static string GenerateSalt()
        {
            var saltBytes = new byte[32];
            using (var rng = RandomNumberGenerator.Create())
            {
                rng.GetBytes(saltBytes);
            }
            return Convert.ToBase64String(saltBytes);
        }

        /// <summary>
        /// Hashes a password with the provided salt using SHA256
        /// </summary>
        public static string HashPassword(string password, string salt)
        {
            if (string.IsNullOrEmpty(password))
                throw new ArgumentException("Password cannot be null or empty", nameof(password));

            if (string.IsNullOrEmpty(salt))
                throw new ArgumentException("Salt cannot be null or empty", nameof(salt));

            var combinedBytes = Encoding.UTF8.GetBytes(password + salt);
            using (var sha256 = SHA256.Create())
            {
                var hashBytes = sha256.ComputeHash(combinedBytes);
                return Convert.ToBase64String(hashBytes);
            }
        }

        /// <summary>
        /// Verifies if a password matches the stored hash
        /// </summary>
        public static bool VerifyPassword(string password, string salt, string storedHash)
        {
            var computedHash = HashPassword(password, salt);
            return computedHash == storedHash;
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IAdminRepository.cs =====
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IAdminRepository : IBaseRepository<AdminUser>
    {
        Task<AdminUser?> GetByEmailAsync(string email);
        Task<bool> EmailExistsAsync(string email);
        Task<IEnumerable<AdminUser>> GetByRoleAsync(string role);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IBaseRepository.cs =====
namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IBaseRepository<T> where T : class
    {
        Task<T?> GetByIdAsync(Guid id);
        Task<IEnumerable<T>> GetAllAsync();
        Task<T> AddAsync(T entity);
        Task UpdateAsync(T entity);
        Task DeleteAsync(Guid id);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IBillerRepository.cs =====
using DigitalWallet.Domain.Entities;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IBillerRepository : IBaseRepository<Biller>
    {
        Task<IEnumerable<Biller>> GetActiveBillersAsync();
        Task<IEnumerable<Biller>> GetByCategoryAsync(BillCategory category);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IBillPaymentRepository.cs =====
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IBillPaymentRepository : IBaseRepository<BillPayment>
    {
        Task<IEnumerable<BillPayment>> GetByUserIdAsync(Guid userId, int pageNumber, int pageSize);
        Task<IEnumerable<BillPayment>> GetByWalletIdAsync(Guid walletId);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IFakeBankAccountRepository.cs =====
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IFakeBankAccountRepository : IBaseRepository<FakeBankAccount>
    {
        Task<FakeBankAccount?> GetByUserIdAsync(Guid userId);
        Task<FakeBankAccount?> GetByAccountNumberAsync(string accountNumber);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IFakeBankTransactionRepository.cs =====
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IFakeBankTransactionRepository : IBaseRepository<FakeBankTransaction>
    {
        Task<IEnumerable<FakeBankTransaction>> GetByUserIdAsync(Guid userId);
        Task<IEnumerable<FakeBankTransaction>> GetPendingTransactionsAsync();
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IFraudLogRepository.cs =====
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IFraudLogRepository : IBaseRepository<FraudLog>
    {
        Task<IEnumerable<FraudLog>> GetByUserIdAsync(Guid userId);
        Task<IEnumerable<FraudLog>> GetRecentLogsAsync(int hours);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IMoneyRequestRepository.cs =====
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IMoneyRequestRepository : IBaseRepository<MoneyRequest>
    {
        Task<IEnumerable<MoneyRequest>> GetByFromUserIdAsync(Guid userId);
        Task<IEnumerable<MoneyRequest>> GetByToUserIdAsync(Guid userId);
        Task<IEnumerable<MoneyRequest>> GetPendingRequestsAsync(Guid userId);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\INotificationRepository.cs =====
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface INotificationRepository : IBaseRepository<Notification>
    {
        Task<IEnumerable<Notification>> GetByUserIdAsync(Guid userId, int pageNumber, int pageSize);
        Task<int> GetUnreadCountAsync(Guid userId);
        Task MarkAsReadAsync(Guid notificationId);
        Task MarkAllAsReadAsync(Guid userId);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IOtpCodeRepository.cs =====
using DigitalWallet.Domain.Entities;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IOtpCodeRepository : IBaseRepository<OtpCode>
    {
        Task<OtpCode?> GetValidOtpAsync(Guid userId, string code, OtpType type);
        Task MarkAsUsedAsync(Guid otpId);
        Task DeleteExpiredOtpsAsync();
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\ITransactionRepository.cs =====
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface ITransactionRepository : IBaseRepository<Transaction>
    {
        Task<IEnumerable<Transaction>> GetByWalletIdAsync(Guid walletId, int pageNumber, int pageSize);
        Task<int> GetCountByWalletIdAsync(Guid walletId);
        Task<IEnumerable<Transaction>> GetRecentTransactionsAsync(Guid walletId, int count);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\ITransferRepository.cs =====
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface ITransferRepository : IBaseRepository<Transfer>
    {
        Task<IEnumerable<Transfer>> GetBySenderWalletIdAsync(Guid walletId, int pageNumber, int pageSize);
        Task<IEnumerable<Transfer>> GetByReceiverWalletIdAsync(Guid walletId, int pageNumber, int pageSize);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IUnitOfWork.cs =====
namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IUnitOfWork : IDisposable
    {
        IUserRepository Users { get; }
        IWalletRepository Wallets { get; }
        ITransactionRepository Transactions { get; }
        ITransferRepository Transfers { get; }
        IMoneyRequestRepository MoneyRequests { get; }
        IOtpCodeRepository OtpCodes { get; }
        IFakeBankAccountRepository FakeBankAccounts { get; }
        IFakeBankTransactionRepository FakeBankTransactions { get; }
        IBillerRepository Billers { get; }
        IBillPaymentRepository BillPayments { get; }
        INotificationRepository Notifications { get; }
        IFraudLogRepository FraudLogs { get; }
        IAdminRepository Admins { get; }  // ✅ ADDED

        Task<int> SaveChangesAsync();
        Task BeginTransactionAsync();
        Task CommitTransactionAsync();
        Task RollbackTransactionAsync();
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IUserRepository.cs =====
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IUserRepository : IBaseRepository<User>
    {
        Task<User?> GetByEmailAsync(string email);
        Task<User?> GetByPhoneNumberAsync(string phoneNumber);
        Task<bool> EmailExistsAsync(string email);
        Task<bool> PhoneExistsAsync(string phoneNumber);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Repositories\IWalletRepository.cs =====
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Interfaces.Repositories
{
    public interface IWalletRepository : IBaseRepository<Wallet>
    {
        Task<Wallet?> GetByUserIdAndCurrencyAsync(Guid userId, string currencyCode);
        Task<IEnumerable<Wallet>> GetAllByUserIdAsync(Guid userId);
        Task<decimal> GetTotalBalanceAsync(Guid userId);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Services\IAdminService.cs =====
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Admin;

namespace DigitalWallet.Application.Interfaces.Services
{
    public interface IAdminService
    {
        Task<ServiceResult<IEnumerable<UserManagementDto>>> GetAllUsersAsync();
        Task<ServiceResult<IEnumerable<FraudLogDto>>> GetFraudLogsAsync();
        Task<ServiceResult<IEnumerable<WalletManagementDto>>> GetAllWalletsAsync(); 
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Services\IAuthService.cs =====
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Auth;

namespace DigitalWallet.Application.Interfaces.Services
{
    public interface IAuthService
    {
        Task<ServiceResult<LoginResponseDto>> RegisterAsync(RegisterRequestDto request);
        Task<ServiceResult<LoginResponseDto>> LoginAsync(LoginRequestDto request);
        Task<ServiceResult<bool>> VerifyOtpAsync(VerifyOtpRequestDto request);
        Task<ServiceResult<bool>> SendOtpAsync(Guid userId, string otpType);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Services\IBillPaymentService.cs =====
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.BillPayment;

namespace DigitalWallet.Application.Interfaces.Services
{
    public interface IBillPaymentService
    {
        Task<ServiceResult<IEnumerable<BillerDto>>> GetAllBillersAsync();
        Task<ServiceResult<BillPaymentDto>> PayBillAsync(Guid userId, PayBillRequestDto request);
        Task<ServiceResult<PaginatedResult<BillPaymentDto>>> GetPaymentHistoryAsync(
            Guid userId, int pageNumber = 1, int pageSize = 20);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Services\IFakeBankService.cs =====
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.FakeBank;

namespace DigitalWallet.Application.Interfaces.Services
{
    public interface IFakeBankService
    {
        Task<ServiceResult<FakeBankTransactionDto>> DepositAsync(DepositRequestDto request);
        Task<ServiceResult<FakeBankTransactionDto>> WithdrawAsync(WithdrawRequestDto request);
        Task<ServiceResult<decimal>> GetBankBalanceAsync(Guid userId);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Services\IMoneyRequestService.cs =====
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.MoneyRequest;

namespace DigitalWallet.Application.Interfaces.Services
{
    public interface IMoneyRequestService
    {
        Task<ServiceResult<MoneyRequestDto>> CreateRequestAsync(Guid fromUserId, CreateMoneyRequestDto request);
        Task<ServiceResult<IEnumerable<MoneyRequestDto>>> GetSentRequestsAsync(Guid userId);
        Task<ServiceResult<IEnumerable<MoneyRequestDto>>> GetReceivedRequestsAsync(Guid userId);
        Task<ServiceResult<bool>> AcceptOrRejectRequestAsync(Guid userId, AcceptRejectRequestDto request);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Services\INotificationService.cs =====
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Notification;

namespace DigitalWallet.Application.Interfaces.Services
{
    public interface INotificationService
    {
        Task<ServiceResult<IEnumerable<NotificationDto>>> GetUserNotificationsAsync(
            Guid userId, int pageNumber = 1, int pageSize = 20);
        Task<ServiceResult<bool>> MarkAsReadAsync(Guid notificationId);
        Task<ServiceResult<int>> GetUnreadCountAsync(Guid userId);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Services\ITransactionService.cs =====
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Transaction;

namespace DigitalWallet.Application.Interfaces.Services
{
    public interface ITransactionService
    {
        Task<ServiceResult<TransactionDto>> GetTransactionByIdAsync(Guid transactionId);
        Task<ServiceResult<PaginatedResult<TransactionDto>>> GetWalletTransactionsAsync(
            Guid walletId, int pageNumber = 1, int pageSize = 20);
        Task<ServiceResult<PaginatedResult<TransactionHistoryDto>>> GetTransactionHistoryAsync(
            Guid walletId, int pageNumber = 1, int pageSize = 20); 
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Services\ITransferService.cs =====
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Transfer;

namespace DigitalWallet.Application.Interfaces.Services
{
    public interface ITransferService
    {
        Task<ServiceResult<TransferResponseDto>> SendMoneyAsync(SendMoneyRequestDto request);
        Task<ServiceResult<PaginatedResult<TransferDto>>> GetTransferHistoryAsync(
            Guid walletId, int pageNumber = 1, int pageSize = 20);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Services\IUserService.cs =====
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Admin;
using DigitalWallet.Application.DTOs.Auth;

namespace DigitalWallet.Application.Interfaces.Services
{
    public interface IUserService
    {
        Task<ServiceResult<UserManagementDto>> GetUserByIdAsync(Guid userId);
        Task<ServiceResult<UserManagementDto>> GetUserByEmailAsync(string email);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Interfaces\Services\IWalletService.cs =====
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Wallet;

namespace DigitalWallet.Application.Interfaces.Services
{
    public interface IWalletService
    {
        Task<ServiceResult<WalletDto>> CreateWalletAsync(CreateWalletRequestDto request);
        Task<ServiceResult<WalletDto>> GetWalletByIdAsync(Guid walletId);
        Task<ServiceResult<IEnumerable<WalletDto>>> GetUserWalletsAsync(Guid userId);
        Task<ServiceResult<WalletBalanceDto>> GetWalletBalanceAsync(Guid walletId);
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Mappings\MappingProfile.cs =====
using AutoMapper;
using DigitalWallet.Application.DTOs.Admin;
using DigitalWallet.Application.DTOs.Auth;
using DigitalWallet.Application.DTOs.BillPayment;
using DigitalWallet.Application.DTOs.FakeBank;
using DigitalWallet.Application.DTOs.MoneyRequest;
using DigitalWallet.Application.DTOs.Notification;
using DigitalWallet.Application.DTOs.Transaction;
using DigitalWallet.Application.DTOs.Transfer;
using DigitalWallet.Application.DTOs.Wallet;
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Mappings
{
    public class MappingProfile : Profile
    {
        public MappingProfile()
        {
            //// User
            //CreateMap<User, UserDto>();

            CreateMap<User, UserManagementDto>()
                .ForMember(dest => dest.KycLevel, opt => opt.MapFrom(src => src.KycLevel.ToString()))
                .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status.ToString()));

            CreateMap<RegisterRequestDto, User>();

            // Wallet mappings
            CreateMap<Wallet, WalletDto>();
            CreateMap<Wallet, WalletBalanceDto>();
            CreateMap<CreateWalletRequestDto, Wallet>();

            CreateMap<Wallet, WalletManagementDto>()
                .ForMember(dest => dest.UserName, opt => opt.MapFrom(src => src.User.FullName))
                .ForMember(dest => dest.UserEmail, opt => opt.MapFrom(src => src.User.Email));

            CreateMap<Domain.Entities.Transaction, TransactionDto>()
                .ForMember(dest => dest.Type, opt => opt.MapFrom(src => src.Type.ToString()))
                .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status.ToString()));

            CreateMap<Domain.Entities.Transaction, TransactionHistoryDto>()
                .ForMember(dest => dest.Type, opt => opt.MapFrom(src => src.Type.ToString()))
                .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status.ToString()));

            // Transfer mappings
            CreateMap<Transfer, TransferDto>()
                .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status.ToString()));

            CreateMap<Transfer, TransferResponseDto>()
                .ForMember(dest => dest.TransferId, opt => opt.MapFrom(src => src.Id))
                .ForMember(dest => dest.ReceiverName, opt => opt.Ignore())
                .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status.ToString()))
                .ForMember(dest => dest.TransferredAt, opt => opt.MapFrom(src => src.CreatedAt));

            // Money Request mappings
            CreateMap<MoneyRequest, MoneyRequestDto>()
                .ForMember(dest => dest.FromUserName, opt => opt.MapFrom(src => src.FromUser.FullName))
                .ForMember(dest => dest.ToUserName, opt => opt.MapFrom(src => src.ToUser.FullName))
                .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status.ToString()));

            // Fake Bank mappings
            CreateMap<FakeBankTransaction, FakeBankTransactionDto>()
                .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status.ToString()));

            // Bill Payment mappings
            CreateMap<Biller, BillerDto>()
                .ForMember(dest => dest.Category, opt => opt.MapFrom(src => src.Category.ToString()));

            CreateMap<BillPayment, BillPaymentDto>()
                .ForMember(dest => dest.BillerName, opt => opt.MapFrom(src => src.Biller.Name))
                .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status.ToString()));

            // Notification mappings
            CreateMap<Notification, NotificationDto>()
                .ForMember(dest => dest.Type, opt => opt.MapFrom(src => src.Type.ToString()));

            // Fraud Log mappings
            CreateMap<FraudLog, FraudLogDto>()
                .ForMember(dest => dest.UserName, opt => opt.MapFrom(src => src.User.FullName))
                .ForMember(dest => dest.Type, opt => opt.MapFrom(src => src.Type.ToString()));
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Services\AdminService.cs =====
using AutoMapper;
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Admin;
using DigitalWallet.Application.Interfaces.Repositories;
using DigitalWallet.Application.Interfaces.Services;

namespace DigitalWallet.Application.Services
{
    public class AdminService : IAdminService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public AdminService(IUnitOfWork unitOfWork, IMapper mapper)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<ServiceResult<IEnumerable<UserManagementDto>>> GetAllUsersAsync()
        {
            try
            {
                var users = await _unitOfWork.Users.GetAllAsync();
                var userDtos = _mapper.Map<IEnumerable<UserManagementDto>>(users);
                return ServiceResult<IEnumerable<UserManagementDto>>.Success(userDtos);
            }
            catch (Exception ex)
            {
                return ServiceResult<IEnumerable<UserManagementDto>>.Failure(
                    $"Error retrieving users: {ex.Message}");
            }
        }

        public async Task<ServiceResult<IEnumerable<FraudLogDto>>> GetFraudLogsAsync()
        {
            try
            {
                var logs = await _unitOfWork.FraudLogs.GetRecentLogsAsync(24);
                var logDtos = _mapper.Map<IEnumerable<FraudLogDto>>(logs);
                return ServiceResult<IEnumerable<FraudLogDto>>.Success(logDtos);
            }
            catch (Exception ex)
            {
                return ServiceResult<IEnumerable<FraudLogDto>>.Failure(
                    $"Error retrieving fraud logs: {ex.Message}");
            }
        }

        public async Task<ServiceResult<IEnumerable<WalletManagementDto>>> GetAllWalletsAsync()
        {
            try
            {
                var wallets = await _unitOfWork.Wallets.GetAllAsync();
                var walletDtos = _mapper.Map<IEnumerable<WalletManagementDto>>(wallets);
                return ServiceResult<IEnumerable<WalletManagementDto>>.Success(walletDtos);
            }
            catch (Exception ex)
            {
                return ServiceResult<IEnumerable<WalletManagementDto>>.Failure(
                    $"Error retrieving wallets: {ex.Message}");
            }
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Services\AuthService.cs =====
using System.Reflection;
using System;
using AutoMapper;
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Auth;
using DigitalWallet.Application.Interfaces.Repositories;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Domain.Entities;
using DigitalWallet.Domain.Enums;
using DigitalWallet.Application.Helpers;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace DigitalWallet.Application.Services
{
    public class AuthService : IAuthService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;
        private readonly JwtTokenGenerator _jwtTokenGenerator;

        public AuthService(
            IUnitOfWork unitOfWork,
            IMapper mapper,
            JwtTokenGenerator jwtTokenGenerator)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
            _jwtTokenGenerator = jwtTokenGenerator;
        }

        public async Task<ServiceResult<LoginResponseDto>> RegisterAsync(RegisterRequestDto request)
        {
            try
            {
                if (await _unitOfWork.Users.EmailExistsAsync(request.Email))
                    return ServiceResult<LoginResponseDto>.Failure("Email already registered");

                if (await _unitOfWork.Users.PhoneExistsAsync(request.PhoneNumber))
                    return ServiceResult<LoginResponseDto>.Failure("Phone number already registered");

                // Use PasswordHasher helper
                var salt = PasswordHasher.GenerateSalt();
                var passwordHash = PasswordHasher.HashPassword(request.Password, salt);

                var user = _mapper.Map<User>(request);
                user.PasswordHash = passwordHash;
                user.Salt = salt;
                user.KycLevel = KycLevel.Basic;
                user.Status = UserStatus.Active;

                await _unitOfWork.Users.AddAsync(user);

                var wallet = new Wallet
                {
                    UserId = user.Id,
                    CurrencyCode = "EGP",
                    Balance = 0,
                    DailyLimit = 5000,
                    MonthlyLimit = 20000
                };

                await _unitOfWork.Wallets.AddAsync(wallet);

                var fakeBankAccount = new FakeBankAccount
                {
                    UserId = user.Id,
                    AccountNumber = OtpGenerator.GenerateAccountNumber(), // Use helper
                    Balance = 10000
                };

                await _unitOfWork.FakeBankAccounts.AddAsync(fakeBankAccount);
                await _unitOfWork.SaveChangesAsync();

                // Use JwtTokenGenerator helper
                var token = _jwtTokenGenerator.GenerateToken(user);
                var refreshToken = OtpGenerator.GenerateRefreshToken(); // Use helper

                var response = new LoginResponseDto
                {
                    Token = token,
                    RefreshToken = refreshToken,
                    ExpiresAt = DateTime.UtcNow.AddHours(24),
                    UserId = user.Id,
                    FullName = user.FullName,
                    Email = user.Email,
                    RequiresOtp = false
                };

                return ServiceResult<LoginResponseDto>.Success(response, "Registration successful");
            }
            catch (Exception ex)
            {
                return ServiceResult<LoginResponseDto>.Failure($"Registration failed: {ex.Message}");
            }
        }

        public async Task<ServiceResult<LoginResponseDto>> LoginAsync(LoginRequestDto request)
        {
            try
            {
                User? user = null;

                if (request.EmailOrPhone.Contains("@"))
                    user = await _unitOfWork.Users.GetByEmailAsync(request.EmailOrPhone);
                else
                    user = await _unitOfWork.Users.GetByPhoneNumberAsync(request.EmailOrPhone);

                if (user == null)
                    return ServiceResult<LoginResponseDto>.Failure("Invalid credentials");

                // Use PasswordHasher helper
                if (!PasswordHasher.VerifyPassword(request.Password, user.Salt, user.PasswordHash))
                    return ServiceResult<LoginResponseDto>.Failure("Invalid credentials");

                if (user.Status != UserStatus.Active)
                    return ServiceResult<LoginResponseDto>.Failure("Account is suspended");

                // Use OtpGenerator helper
                var otpCode = OtpGenerator.GenerateOtpCode();
                var otp = new OtpCode
                {
                    UserId = user.Id,
                    Code = otpCode,
                    Type = OtpType.Login,
                    ExpiresAt = DateTime.UtcNow.AddMinutes(5),
                    IsUsed = false
                };

                await _unitOfWork.OtpCodes.AddAsync(otp);
                await _unitOfWork.SaveChangesAsync();

                var response = new LoginResponseDto
                {
                    UserId = user.Id,
                    FullName = user.FullName,
                    Email = user.Email,
                    RequiresOtp = true,
                    Token = string.Empty,
                    RefreshToken = string.Empty
                };

                return ServiceResult<LoginResponseDto>.Success(
                    response,
                    $"OTP sent to your phone. Code: {otpCode}");
            }
            catch (Exception ex)
            {
                return ServiceResult<LoginResponseDto>.Failure($"Login failed: {ex.Message}");
            }
        }

        public async Task<ServiceResult<bool>> VerifyOtpAsync(VerifyOtpRequestDto request)
        {
            try
            {
                var otp = await _unitOfWork.OtpCodes.GetValidOtpAsync(
                    request.UserId,
                    request.Code,
                    OtpType.Login);

                if (otp == null)
                    return ServiceResult<bool>.Failure("Invalid or expired OTP");

                await _unitOfWork.OtpCodes.MarkAsUsedAsync(otp.Id);

                var user = await _unitOfWork.Users.GetByIdAsync(request.UserId);
                if (user != null)
                {
                    user.LastLoginAt = DateTime.UtcNow;
                    await _unitOfWork.Users.UpdateAsync(user);
                }

                await _unitOfWork.SaveChangesAsync();

                return ServiceResult<bool>.Success(true, "OTP verified successfully");
            }
            catch (Exception ex)
            {
                return ServiceResult<bool>.Failure($"OTP verification failed: {ex.Message}");
            }
        }

        public async Task<ServiceResult<bool>> SendOtpAsync(Guid userId, string otpType)
        {
            try
            {
                var user = await _unitOfWork.Users.GetByIdAsync(userId);
                if (user == null)
                    return ServiceResult<bool>.Failure("User not found");

                // Use OtpGenerator helper
                var otpCode = OtpGenerator.GenerateOtpCode();
                var type = Enum.Parse<OtpType>(otpType, true);

                var otp = new OtpCode
                {
                    UserId = userId,
                    Code = otpCode,
                    Type = type,
                    ExpiresAt = DateTime.UtcNow.AddMinutes(5),
                    IsUsed = false
                };

                await _unitOfWork.OtpCodes.AddAsync(otp);
                await _unitOfWork.SaveChangesAsync();

                return ServiceResult<bool>.Success(
                    true,
                    $"OTP sent successfully. Code: {otpCode}");
            }
            catch (Exception ex)
            {
                return ServiceResult<bool>.Failure($"Failed to send OTP: {ex.Message}");
            }
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Services\BillPaymentService.cs =====
using AutoMapper;
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.BillPayment;
using DigitalWallet.Application.Interfaces.Repositories;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Domain.Entities;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.Services
{
    public class BillPaymentService : IBillPaymentService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public BillPaymentService(IUnitOfWork unitOfWork, IMapper mapper)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<ServiceResult<IEnumerable<BillerDto>>> GetAllBillersAsync()
        {
            try
            {
                var billers = await _unitOfWork.Billers.GetActiveBillersAsync();
                var billerDtos = _mapper.Map<IEnumerable<BillerDto>>(billers);
                return ServiceResult<IEnumerable<BillerDto>>.Success(billerDtos);
            }
            catch (Exception ex)
            {
                return ServiceResult<IEnumerable<BillerDto>>.Failure(
                    $"Error retrieving billers: {ex.Message}");
            }
        }

        public async Task<ServiceResult<BillPaymentDto>> PayBillAsync(
            Guid userId,
            PayBillRequestDto request)
        {
            await _unitOfWork.BeginTransactionAsync();
            try
            {
                // Verify OTP
                var otp = await _unitOfWork.OtpCodes.GetValidOtpAsync(
                    userId,
                    request.OtpCode,
                    OtpType.Transfer);

                if (otp == null)
                    return ServiceResult<BillPaymentDto>.Failure("Invalid or expired OTP");

                // Verify wallet
                var wallet = await _unitOfWork.Wallets.GetByIdAsync(request.WalletId);
                if (wallet == null || wallet.UserId != userId)
                    return ServiceResult<BillPaymentDto>.Failure("Wallet not found");

                if (wallet.Balance < request.Amount)
                    return ServiceResult<BillPaymentDto>.Failure("Insufficient balance");

                // Verify biller
                var biller = await _unitOfWork.Billers.GetByIdAsync(request.BillerId);
                if (biller == null || !biller.IsActive)
                    return ServiceResult<BillPaymentDto>.Failure("Biller not available");

                // Create bill payment
                var billPayment = new BillPayment
                {
                    UserId = userId,
                    WalletId = wallet.Id,
                    BillerId = biller.Id,
                    Amount = request.Amount,
                    CurrencyCode = wallet.CurrencyCode,
                    Status = TransactionStatus.Success,
                    ReceiptPath = $"/receipts/bill_{Guid.NewGuid()}.pdf"
                };

                await _unitOfWork.BillPayments.AddAsync(billPayment);

                // Update wallet balance
                wallet.Balance -= request.Amount;
                await _unitOfWork.Wallets.UpdateAsync(wallet);

                // Create transaction record
                var transaction = new Domain.Entities.Transaction
                {
                    WalletId = wallet.Id,
                    Type = TransactionType.Bill,
                    Amount = -request.Amount,
                    CurrencyCode = wallet.CurrencyCode,
                    Status = TransactionStatus.Success,
                    Description = $"Bill payment - {biller.Name}",
                    Reference = billPayment.Id.ToString()
                };

                await _unitOfWork.Transactions.AddAsync(transaction);

                // Mark OTP as used
                await _unitOfWork.OtpCodes.MarkAsUsedAsync(otp.Id);

                // Create notification
                var notification = new Notification
                {
                    UserId = userId,
                    Title = "Bill Payment Successful",
                    Body = $"Paid {request.Amount} {wallet.CurrencyCode} to {biller.Name}",
                    Type = NotificationType.Transaction,
                    IsRead = false
                };

                await _unitOfWork.Notifications.AddAsync(notification);

                await _unitOfWork.SaveChangesAsync();
                await _unitOfWork.CommitTransactionAsync();

                var paymentDto = _mapper.Map<BillPaymentDto>(billPayment);
                return ServiceResult<BillPaymentDto>.Success(
                    paymentDto,
                    "Bill payment successful");
            }
            catch (Exception ex)
            {
                await _unitOfWork.RollbackTransactionAsync();
                return ServiceResult<BillPaymentDto>.Failure(
                    $"Bill payment failed: {ex.Message}");
            }
        }

        public async Task<ServiceResult<PaginatedResult<BillPaymentDto>>> GetPaymentHistoryAsync(
            Guid userId, int pageNumber = 1, int pageSize = 20)
        {
            try
            {
                var payments = await _unitOfWork.BillPayments.GetByUserIdAsync(
                    userId, pageNumber, pageSize);
                var totalCount = payments.Count();

                var paymentDtos = _mapper.Map<List<BillPaymentDto>>(payments);
                var paginatedResult = PaginatedResult<BillPaymentDto>.Create(
                    paymentDtos, totalCount, pageNumber, pageSize);

                return ServiceResult<PaginatedResult<BillPaymentDto>>.Success(paginatedResult);
            }
            catch (Exception ex)
            {
                return ServiceResult<PaginatedResult<BillPaymentDto>>.Failure(
                    $"Error retrieving payment history: {ex.Message}");
            }
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Services\FakeBankService.cs =====
using AutoMapper;
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.FakeBank;
using DigitalWallet.Application.Interfaces.Repositories;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Domain.Entities;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.Services
{
    public class FakeBankService : IFakeBankService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public FakeBankService(IUnitOfWork unitOfWork, IMapper mapper)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<ServiceResult<FakeBankTransactionDto>> DepositAsync(DepositRequestDto request)
        {
            await _unitOfWork.BeginTransactionAsync();
            try
            {
                var bankAccount = await _unitOfWork.FakeBankAccounts.GetByUserIdAsync(request.UserId);
                if (bankAccount == null)
                    return ServiceResult<FakeBankTransactionDto>.Failure("Bank account not found");

                if (bankAccount.Balance < request.Amount)
                    return ServiceResult<FakeBankTransactionDto>.Failure(
                        "Insufficient bank balance");

                var wallet = await _unitOfWork.Wallets.GetByUserIdAndCurrencyAsync(
                    request.UserId, "EGP");
                if (wallet == null)
                    return ServiceResult<FakeBankTransactionDto>.Failure("Wallet not found");

                // Create fake bank transaction
                var bankTransaction = new FakeBankTransaction
                {
                    UserId = request.UserId,
                    Amount = request.Amount,
                    Type = "deposit",
                    Status = TransactionStatus.Success,
                    DelaySeconds = 5 // Simulate processing delay
                };

                await _unitOfWork.FakeBankTransactions.AddAsync(bankTransaction);

                // Simulate delay (in production, use background job)
                // For now, process immediately
                bankAccount.Balance -= request.Amount;
                wallet.Balance += request.Amount;

                await _unitOfWork.FakeBankAccounts.UpdateAsync(bankAccount);
                await _unitOfWork.Wallets.UpdateAsync(wallet);

                // Create transaction record
                var transaction = new Domain.Entities.Transaction
                {
                    WalletId = wallet.Id,
                    Type = TransactionType.Deposit,
                    Amount = request.Amount,
                    CurrencyCode = "EGP",
                    Status = TransactionStatus.Success,
                    Description = "Deposit from bank account",
                    Reference = bankTransaction.Id.ToString()
                };

                await _unitOfWork.Transactions.AddAsync(transaction);

                // Create notification
                var notification = new Notification
                {
                    UserId = request.UserId,
                    Title = "Deposit Successful",
                    Body = $"Deposited {request.Amount} EGP to your wallet",
                    Type = NotificationType.Transaction,
                    IsRead = false
                };

                await _unitOfWork.Notifications.AddAsync(notification);

                await _unitOfWork.SaveChangesAsync();
                await _unitOfWork.CommitTransactionAsync();

                var transactionDto = _mapper.Map<FakeBankTransactionDto>(bankTransaction);
                return ServiceResult<FakeBankTransactionDto>.Success(
                    transactionDto,
                    "Deposit successful");
            }
            catch (Exception ex)
            {
                await _unitOfWork.RollbackTransactionAsync();
                return ServiceResult<FakeBankTransactionDto>.Failure(
                    $"Deposit failed: {ex.Message}");
            }
        }

        public async Task<ServiceResult<FakeBankTransactionDto>> WithdrawAsync(WithdrawRequestDto request)
        {
            await _unitOfWork.BeginTransactionAsync();
            try
            {
                var wallet = await _unitOfWork.Wallets.GetByUserIdAndCurrencyAsync(
                    request.UserId, "EGP");
                if (wallet == null)
                    return ServiceResult<FakeBankTransactionDto>.Failure("Wallet not found");

                if (wallet.Balance < request.Amount)
                    return ServiceResult<FakeBankTransactionDto>.Failure(
                        "Insufficient wallet balance");

                var bankAccount = await _unitOfWork.FakeBankAccounts.GetByUserIdAsync(request.UserId);
                if (bankAccount == null)
                    return ServiceResult<FakeBankTransactionDto>.Failure("Bank account not found");

                // Create fake bank transaction
                var bankTransaction = new FakeBankTransaction
                {
                    UserId = request.UserId,
                    Amount = request.Amount,
                    Type = "withdraw",
                    Status = TransactionStatus.Success,
                    DelaySeconds = 5
                };

                await _unitOfWork.FakeBankTransactions.AddAsync(bankTransaction);

                // Process withdrawal
                wallet.Balance -= request.Amount;
                bankAccount.Balance += request.Amount;

                await _unitOfWork.Wallets.UpdateAsync(wallet);
                await _unitOfWork.FakeBankAccounts.UpdateAsync(bankAccount);

                // Create transaction record
                var transaction = new Domain.Entities.Transaction
                {
                    WalletId = wallet.Id,
                    Type = TransactionType.Withdraw,
                    Amount = -request.Amount,
                    CurrencyCode = "EGP",
                    Status = TransactionStatus.Success,
                    Description = "Withdrawal to bank account",
                    Reference = bankTransaction.Id.ToString()
                };

                await _unitOfWork.Transactions.AddAsync(transaction);

                // Create notification
                var notification = new Notification
                {
                    UserId = request.UserId,
                    Title = "Withdrawal Successful",
                    Body = $"Withdrawn {request.Amount} EGP from your wallet",
                    Type = NotificationType.Transaction,
                    IsRead = false
                };

                await _unitOfWork.Notifications.AddAsync(notification);

                await _unitOfWork.SaveChangesAsync();
                await _unitOfWork.CommitTransactionAsync();

                var transactionDto = _mapper.Map<FakeBankTransactionDto>(bankTransaction);
                return ServiceResult<FakeBankTransactionDto>.Success(
                    transactionDto,
                    "Withdrawal successful");
            }
            catch (Exception ex)
            {
                await _unitOfWork.RollbackTransactionAsync();
                return ServiceResult<FakeBankTransactionDto>.Failure(
                    $"Withdrawal failed: {ex.Message}");
            }
        }

        public async Task<ServiceResult<decimal>> GetBankBalanceAsync(Guid userId)
        {
            try
            {
                var bankAccount = await _unitOfWork.FakeBankAccounts.GetByUserIdAsync(userId);
                if (bankAccount == null)
                    return ServiceResult<decimal>.Failure("Bank account not found");

                return ServiceResult<decimal>.Success(bankAccount.Balance);
            }
            catch (Exception ex)
            {
                return ServiceResult<decimal>.Failure(
                    $"Error retrieving bank balance: {ex.Message}");
            }
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Services\MoneyRequestService.cs =====
using AutoMapper;
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.MoneyRequest;
using DigitalWallet.Application.Interfaces.Repositories;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Domain.Entities;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.Services
{
    public class MoneyRequestService : IMoneyRequestService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public MoneyRequestService(IUnitOfWork unitOfWork, IMapper mapper)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<ServiceResult<MoneyRequestDto>> CreateRequestAsync(
            Guid fromUserId,
            CreateMoneyRequestDto request)
        {
            try
            {
                // Find receiver
                User? toUser = null;
                if (request.ToUserPhoneOrEmail.Contains("@"))
                    toUser = await _unitOfWork.Users.GetByEmailAsync(request.ToUserPhoneOrEmail);
                else
                    toUser = await _unitOfWork.Users.GetByPhoneNumberAsync(request.ToUserPhoneOrEmail);

                if (toUser == null)
                    return ServiceResult<MoneyRequestDto>.Failure("User not found");

                if (fromUserId == toUser.Id)
                    return ServiceResult<MoneyRequestDto>.Failure(
                        "Cannot request money from yourself");

                var moneyRequest = new MoneyRequest
                {
                    FromUserId = fromUserId,
                    ToUserId = toUser.Id,
                    Amount = request.Amount,
                    CurrencyCode = request.CurrencyCode,
                    Status = MoneyRequestStatus.Pending
                };

                await _unitOfWork.MoneyRequests.AddAsync(moneyRequest);

                // Create notification for receiver
                var notification = new Notification
                {
                    UserId = toUser.Id,
                    Title = "Money Request",
                    Body = $"Money request for {request.Amount} {request.CurrencyCode}",
                    Type = NotificationType.Transaction,
                    IsRead = false
                };

                await _unitOfWork.Notifications.AddAsync(notification);
                await _unitOfWork.SaveChangesAsync();

                var requestDto = _mapper.Map<MoneyRequestDto>(moneyRequest);
                return ServiceResult<MoneyRequestDto>.Success(
                    requestDto,
                    "Money request sent successfully");
            }
            catch (Exception ex)
            {
                return ServiceResult<MoneyRequestDto>.Failure(
                    $"Error creating money request: {ex.Message}");
            }
        }

        public async Task<ServiceResult<IEnumerable<MoneyRequestDto>>> GetSentRequestsAsync(Guid userId)
        {
            try
            {
                var requests = await _unitOfWork.MoneyRequests.GetByFromUserIdAsync(userId);
                var requestDtos = _mapper.Map<IEnumerable<MoneyRequestDto>>(requests);
                return ServiceResult<IEnumerable<MoneyRequestDto>>.Success(requestDtos);
            }
            catch (Exception ex)
            {
                return ServiceResult<IEnumerable<MoneyRequestDto>>.Failure(
                    $"Error retrieving sent requests: {ex.Message}");
            }
        }

        public async Task<ServiceResult<IEnumerable<MoneyRequestDto>>> GetReceivedRequestsAsync(
            Guid userId)
        {
            try
            {
                var requests = await _unitOfWork.MoneyRequests.GetByToUserIdAsync(userId);
                var requestDtos = _mapper.Map<IEnumerable<MoneyRequestDto>>(requests);
                return ServiceResult<IEnumerable<MoneyRequestDto>>.Success(requestDtos);
            }
            catch (Exception ex)
            {
                return ServiceResult<IEnumerable<MoneyRequestDto>>.Failure(
                    $"Error retrieving received requests: {ex.Message}");
            }
        }

        public async Task<ServiceResult<bool>> AcceptOrRejectRequestAsync(
            Guid userId,
            AcceptRejectRequestDto request)
        {
            await _unitOfWork.BeginTransactionAsync();
            try
            {
                var moneyRequest = await _unitOfWork.MoneyRequests.GetByIdAsync(request.RequestId);
                if (moneyRequest == null)
                    return ServiceResult<bool>.Failure("Money request not found");

                if (moneyRequest.ToUserId != userId)
                    return ServiceResult<bool>.Failure("Unauthorized");

                if (moneyRequest.Status != MoneyRequestStatus.Pending)
                    return ServiceResult<bool>.Failure("Request already processed");

                if (!request.Accept)
                {
                    moneyRequest.Status = MoneyRequestStatus.Rejected;
                    await _unitOfWork.MoneyRequests.UpdateAsync(moneyRequest);
                    await _unitOfWork.SaveChangesAsync();
                    await _unitOfWork.CommitTransactionAsync();

                    return ServiceResult<bool>.Success(true, "Request rejected");
                }

                // Accept request - process transfer
                // Verify OTP
                if (string.IsNullOrEmpty(request.OtpCode))
                    return ServiceResult<bool>.Failure("OTP required");

                var otp = await _unitOfWork.OtpCodes.GetValidOtpAsync(
                    userId,
                    request.OtpCode,
                    OtpType.Transfer);

                if (otp == null)
                    return ServiceResult<bool>.Failure("Invalid or expired OTP");

                // Get wallets
                var senderWallet = await _unitOfWork.Wallets.GetByUserIdAndCurrencyAsync(
                    userId,
                    moneyRequest.CurrencyCode);
                var receiverWallet = await _unitOfWork.Wallets.GetByUserIdAndCurrencyAsync(
                    moneyRequest.FromUserId,
                    moneyRequest.CurrencyCode);

                if (senderWallet == null || receiverWallet == null)
                    return ServiceResult<bool>.Failure("Wallet not found");

                if (senderWallet.Balance < moneyRequest.Amount)
                    return ServiceResult<bool>.Failure("Insufficient balance");

                // Update balances
                senderWallet.Balance -= moneyRequest.Amount;
                receiverWallet.Balance += moneyRequest.Amount;

                await _unitOfWork.Wallets.UpdateAsync(senderWallet);
                await _unitOfWork.Wallets.UpdateAsync(receiverWallet);

                // Update request status
                moneyRequest.Status = MoneyRequestStatus.Accepted;
                await _unitOfWork.MoneyRequests.UpdateAsync(moneyRequest);

                // Mark OTP as used
                await _unitOfWork.OtpCodes.MarkAsUsedAsync(otp.Id);

                await _unitOfWork.SaveChangesAsync();
                await _unitOfWork.CommitTransactionAsync();

                return ServiceResult<bool>.Success(true, "Request accepted and payment processed");
            }
            catch (Exception ex)
            {
                await _unitOfWork.RollbackTransactionAsync();
                return ServiceResult<bool>.Failure($"Error processing request: {ex.Message}");
            }
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Services\NotificationService.cs =====
using AutoMapper;
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Notification;
using DigitalWallet.Application.Interfaces.Repositories;
using DigitalWallet.Application.Interfaces.Services;

namespace DigitalWallet.Application.Services
{
    public class NotificationService : INotificationService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public NotificationService(IUnitOfWork unitOfWork, IMapper mapper)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<ServiceResult<IEnumerable<NotificationDto>>> GetUserNotificationsAsync(
            Guid userId, int pageNumber = 1, int pageSize = 20)
        {
            try
            {
                var notifications = await _unitOfWork.Notifications.GetByUserIdAsync(
                    userId, pageNumber, pageSize);
                var notificationDtos = _mapper.Map<IEnumerable<NotificationDto>>(notifications);
                return ServiceResult<IEnumerable<NotificationDto>>.Success(notificationDtos);
            }
            catch (Exception ex)
            {
                return ServiceResult<IEnumerable<NotificationDto>>.Failure(
                    $"Error retrieving notifications: {ex.Message}");
            }
        }

        public async Task<ServiceResult<bool>> MarkAsReadAsync(Guid notificationId)
        {
            try
            {
                await _unitOfWork.Notifications.MarkAsReadAsync(notificationId);
                await _unitOfWork.SaveChangesAsync();
                return ServiceResult<bool>.Success(true, "Notification marked as read");
            }
            catch (Exception ex)
            {
                return ServiceResult<bool>.Failure(
                    $"Error marking notification as read: {ex.Message}");
            }
        }

        public async Task<ServiceResult<int>> GetUnreadCountAsync(Guid userId)
        {
            try
            {
                var count = await _unitOfWork.Notifications.GetUnreadCountAsync(userId);
                return ServiceResult<int>.Success(count);
            }
            catch (Exception ex)
            {
                return ServiceResult<int>.Failure(
                    $"Error getting unread count: {ex.Message}");
            }
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Services\TransactionService.cs =====
using AutoMapper;
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Transaction;
using DigitalWallet.Application.Interfaces.Repositories;
using DigitalWallet.Application.Interfaces.Services;

namespace DigitalWallet.Application.Services
{
    public class TransactionService : ITransactionService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public TransactionService(IUnitOfWork unitOfWork, IMapper mapper)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<ServiceResult<TransactionDto>> GetTransactionByIdAsync(Guid transactionId)
        {
            try
            {
                var transaction = await _unitOfWork.Transactions.GetByIdAsync(transactionId);
                if (transaction == null)
                    return ServiceResult<TransactionDto>.Failure("Transaction not found");

                var transactionDto = _mapper.Map<TransactionDto>(transaction);
                return ServiceResult<TransactionDto>.Success(transactionDto);
            }
            catch (Exception ex)
            {
                return ServiceResult<TransactionDto>.Failure(
                    $"Error retrieving transaction: {ex.Message}");
            }
        }

        public async Task<ServiceResult<PaginatedResult<TransactionDto>>> GetWalletTransactionsAsync(
            Guid walletId, int pageNumber = 1, int pageSize = 20)
        {
            try
            {
                var transactions = await _unitOfWork.Transactions.GetByWalletIdAsync(
                    walletId, pageNumber, pageSize);
                var totalCount = await _unitOfWork.Transactions.GetCountByWalletIdAsync(walletId);

                var transactionDtos = _mapper.Map<List<TransactionDto>>(transactions);
                var paginatedResult = PaginatedResult<TransactionDto>.Create(
                    transactionDtos, totalCount, pageNumber, pageSize);

                return ServiceResult<PaginatedResult<TransactionDto>>.Success(paginatedResult);
            }
            catch (Exception ex)
            {
                return ServiceResult<PaginatedResult<TransactionDto>>.Failure(
                    $"Error retrieving transactions: {ex.Message}");
            }
        }

        public async Task<ServiceResult<PaginatedResult<TransactionHistoryDto>>> GetTransactionHistoryAsync(
            Guid walletId, int pageNumber = 1, int pageSize = 20)
        {
            try
            {
                var transactions = await _unitOfWork.Transactions.GetByWalletIdAsync(
                    walletId, pageNumber, pageSize);
                var totalCount = await _unitOfWork.Transactions.GetCountByWalletIdAsync(walletId);

                var historyDtos = _mapper.Map<List<TransactionHistoryDto>>(transactions);
                var paginatedResult = PaginatedResult<TransactionHistoryDto>.Create(
                    historyDtos, totalCount, pageNumber, pageSize);

                return ServiceResult<PaginatedResult<TransactionHistoryDto>>.Success(paginatedResult);
            }
            catch (Exception ex)
            {
                return ServiceResult<PaginatedResult<TransactionHistoryDto>>.Failure(
                    $"Error retrieving transaction history: {ex.Message}");
            }
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Services\TransferService.cs =====
using AutoMapper;
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Transfer;
using DigitalWallet.Application.Interfaces.Repositories;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Domain.Entities;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Application.Services
{
    public class TransferService : ITransferService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public TransferService(IUnitOfWork unitOfWork, IMapper mapper)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<ServiceResult<TransferResponseDto>> SendMoneyAsync(SendMoneyRequestDto request)
        {
            await _unitOfWork.BeginTransactionAsync();
            try
            {
                // Verify OTP
                var senderWallet = await _unitOfWork.Wallets.GetByIdAsync(request.SenderWalletId);
                if (senderWallet == null)
                    return ServiceResult<TransferResponseDto>.Failure("Sender wallet not found");

                var otp = await _unitOfWork.OtpCodes.GetValidOtpAsync(
                    senderWallet.UserId,
                    request.OtpCode,
                    OtpType.Transfer);

                if (otp == null)
                    return ServiceResult<TransferResponseDto>.Failure("Invalid or expired OTP");

                // Find receiver
                User? receiver = null;
                if (request.ReceiverPhoneOrEmail.Contains("@"))
                    receiver = await _unitOfWork.Users.GetByEmailAsync(request.ReceiverPhoneOrEmail);
                else
                    receiver = await _unitOfWork.Users.GetByPhoneNumberAsync(request.ReceiverPhoneOrEmail);

                if (receiver == null)
                    return ServiceResult<TransferResponseDto>.Failure("Receiver not found");

                // Get receiver wallet
                var receiverWallet = await _unitOfWork.Wallets.GetByUserIdAndCurrencyAsync(
                    receiver.Id,
                    senderWallet.CurrencyCode);

                if (receiverWallet == null)
                    return ServiceResult<TransferResponseDto>.Failure(
                        $"Receiver doesn't have a {senderWallet.CurrencyCode} wallet");

                // Validate balance
                if (senderWallet.Balance < request.Amount)
                    return ServiceResult<TransferResponseDto>.Failure("Insufficient balance");

                // Check daily limit
                // TODO: Implement daily limit check

                // Create transfer
                var transfer = new Transfer
                {
                    SenderWalletId = senderWallet.Id,
                    ReceiverWalletId = receiverWallet.Id,
                    Amount = request.Amount,
                    CurrencyCode = senderWallet.CurrencyCode,
                    Status = TransactionStatus.Success
                };

                await _unitOfWork.Transfers.AddAsync(transfer);

                // Update balances
                senderWallet.Balance -= request.Amount;
                receiverWallet.Balance += request.Amount;

                await _unitOfWork.Wallets.UpdateAsync(senderWallet);
                await _unitOfWork.Wallets.UpdateAsync(receiverWallet);

                // Create transactions
                var senderTransaction = new Domain.Entities.Transaction
                {
                    WalletId = senderWallet.Id,
                    Type = TransactionType.Transfer,
                    Amount = -request.Amount,
                    CurrencyCode = senderWallet.CurrencyCode,
                    Status = TransactionStatus.Success,
                    Description = request.Description ?? $"Transfer to {receiver.FullName}",
                    Reference = transfer.Id.ToString()
                };

                var receiverTransaction = new Domain.Entities.Transaction
                {
                    WalletId = receiverWallet.Id,
                    Type = TransactionType.Transfer,
                    Amount = request.Amount,
                    CurrencyCode = receiverWallet.CurrencyCode,
                    Status = TransactionStatus.Success,
                    Description = $"Transfer from {senderWallet.User?.FullName ?? "User"}",
                    Reference = transfer.Id.ToString()
                };

                await _unitOfWork.Transactions.AddAsync(senderTransaction);
                await _unitOfWork.Transactions.AddAsync(receiverTransaction);

                // Mark OTP as used
                await _unitOfWork.OtpCodes.MarkAsUsedAsync(otp.Id);

                // Create notifications
                var senderNotification = new Notification
                {
                    UserId = senderWallet.UserId,
                    Title = "Transfer Sent",
                    Body = $"You sent {request.Amount} {senderWallet.CurrencyCode} to {receiver.FullName}",
                    Type = NotificationType.Transaction,
                    IsRead = false
                };

                var receiverNotification = new Notification
                {
                    UserId = receiver.Id,
                    Title = "Money Received",
                    Body = $"You received {request.Amount} {receiverWallet.CurrencyCode}",
                    Type = NotificationType.Transaction,
                    IsRead = false
                };

                await _unitOfWork.Notifications.AddAsync(senderNotification);
                await _unitOfWork.Notifications.AddAsync(receiverNotification);

                await _unitOfWork.SaveChangesAsync();
                await _unitOfWork.CommitTransactionAsync();

                var response = new TransferResponseDto
                {
                    TransferId = transfer.Id,
                    ReceiverName = receiver.FullName,
                    Amount = request.Amount,
                    CurrencyCode = senderWallet.CurrencyCode,
                    Status = "Success",
                    TransferredAt = DateTime.UtcNow
                };

                return ServiceResult<TransferResponseDto>.Success(
                    response,
                    "Transfer completed successfully");
            }
            catch (Exception ex)
            {
                await _unitOfWork.RollbackTransactionAsync();
                return ServiceResult<TransferResponseDto>.Failure($"Transfer failed: {ex.Message}");
            }
        }

        public async Task<ServiceResult<PaginatedResult<TransferDto>>> GetTransferHistoryAsync(
            Guid walletId, int pageNumber = 1, int pageSize = 20)
        {
            try
            {
                var sentTransfers = await _unitOfWork.Transfers.GetBySenderWalletIdAsync(
                    walletId, pageNumber, pageSize);
                var receivedTransfers = await _unitOfWork.Transfers.GetByReceiverWalletIdAsync(
                    walletId, pageNumber, pageSize);

                var allTransfers = sentTransfers.Concat(receivedTransfers)
                    .OrderByDescending(t => t.CreatedAt)
                    .Take(pageSize)
                    .ToList();

                var transferDtos = _mapper.Map<List<TransferDto>>(allTransfers);
                var totalCount = allTransfers.Count;

                var paginatedResult = PaginatedResult<TransferDto>.Create(
                    transferDtos, totalCount, pageNumber, pageSize);

                return ServiceResult<PaginatedResult<TransferDto>>.Success(paginatedResult);
            }
            catch (Exception ex)
            {
                return ServiceResult<PaginatedResult<TransferDto>>.Failure(
                    $"Error retrieving transfer history: {ex.Message}");
            }
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Services\UserService.cs =====
using AutoMapper;
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Admin;
using DigitalWallet.Application.DTOs.Auth;
using DigitalWallet.Application.Interfaces.Repositories;
using DigitalWallet.Application.Interfaces.Services;

namespace DigitalWallet.Application.Services
{
    public class UserService : IUserService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public UserService(IUnitOfWork unitOfWork, IMapper mapper)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<ServiceResult<UserManagementDto>> GetUserByIdAsync(Guid userId)
        {
            try
            {
                var user = await _unitOfWork.Users.GetByIdAsync(userId);
                if (user == null)
                    return ServiceResult<UserManagementDto>.Failure("User not found");

                var userDto = _mapper.Map<UserManagementDto>(user);
                return ServiceResult<UserManagementDto>.Success(userDto);
            }
            catch (Exception ex)
            {
                return ServiceResult<UserManagementDto>.Failure($"Error retrieving user: {ex.Message}");
            }
        }

        public async Task<ServiceResult<UserManagementDto>> GetUserByEmailAsync(string email)
        {
            try
            {
                var user = await _unitOfWork.Users.GetByEmailAsync(email);
                if (user == null)
                    return ServiceResult<UserDto>.Failure("User not found");

                var userDto = _mapper.Map<UserDto>(user);
                return ServiceResult<UserDto>.Success(userDto);
            }
            catch (Exception ex)
            {
                return ServiceResult<UserDto>.Failure($"Error retrieving user: {ex.Message}");
            }
        }

        public async Task<ServiceResult<UserDto>> GetUserByPhoneAsync(string phone)
        {
            try
            {
                var user = await _unitOfWork.Users.GetByPhoneNumberAsync(phone);
                if (user == null)
                    return ServiceResult<UserManagementDto>.Failure("User not found");

                var userDto = _mapper.Map<UserManagementDto>(user);
                return ServiceResult<UserManagementDto>.Success(userDto);
            }
            catch (Exception ex)
            {
                return ServiceResult<UserManagementDto>.Failure($"Error retrieving user: {ex.Message}");
            }
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Services\WalletService.cs =====
using AutoMapper;
using DigitalWallet.Application.Common;
using DigitalWallet.Application.DTOs.Wallet;
using DigitalWallet.Application.Interfaces.Repositories;
using DigitalWallet.Application.Interfaces.Services;
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Application.Services
{
    public class WalletService : IWalletService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public WalletService(IUnitOfWork unitOfWork, IMapper mapper)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<ServiceResult<WalletDto>> CreateWalletAsync(CreateWalletRequestDto request)
        {
            try
            {
                // Check if user exists
                var user = await _unitOfWork.Users.GetByIdAsync(request.UserId);
                if (user == null)
                    return ServiceResult<WalletDto>.Failure("User not found");

                // Check if wallet already exists for this currency
                var existingWallet = await _unitOfWork.Wallets.GetByUserIdAndCurrencyAsync(
                    request.UserId,
                    request.CurrencyCode);

                if (existingWallet != null)
                    return ServiceResult<WalletDto>.Failure(
                        $"Wallet with currency {request.CurrencyCode} already exists");

                var wallet = new Wallet
                {
                    UserId = request.UserId,
                    CurrencyCode = request.CurrencyCode,
                    Balance = 0,
                    DailyLimit = 5000,
                    MonthlyLimit = 20000
                };

                await _unitOfWork.Wallets.AddAsync(wallet);
                await _unitOfWork.SaveChangesAsync();

                var walletDto = _mapper.Map<WalletDto>(wallet);
                return ServiceResult<WalletDto>.Success(walletDto, "Wallet created successfully");
            }
            catch (Exception ex)
            {
                return ServiceResult<WalletDto>.Failure($"Error creating wallet: {ex.Message}");
            }
        }

        public async Task<ServiceResult<WalletDto>> GetWalletByIdAsync(Guid walletId)
        {
            try
            {
                var wallet = await _unitOfWork.Wallets.GetByIdAsync(walletId);
                if (wallet == null)
                    return ServiceResult<WalletDto>.Failure("Wallet not found");

                var walletDto = _mapper.Map<WalletDto>(wallet);
                return ServiceResult<WalletDto>.Success(walletDto);
            }
            catch (Exception ex)
            {
                return ServiceResult<WalletDto>.Failure($"Error retrieving wallet: {ex.Message}");
            }
        }

        public async Task<ServiceResult<IEnumerable<WalletDto>>> GetUserWalletsAsync(Guid userId)
        {
            try
            {
                var wallets = await _unitOfWork.Wallets.GetAllByUserIdAsync(userId);
                var walletDtos = _mapper.Map<IEnumerable<WalletDto>>(wallets);
                return ServiceResult<IEnumerable<WalletDto>>.Success(walletDtos);
            }
            catch (Exception ex)
            {
                return ServiceResult<IEnumerable<WalletDto>>.Failure(
                    $"Error retrieving wallets: {ex.Message}");
            }
        }

        public async Task<ServiceResult<WalletBalanceDto>> GetWalletBalanceAsync(Guid walletId)
        {
            try
            {
                var wallet = await _unitOfWork.Wallets.GetByIdAsync(walletId);
                if (wallet == null)
                    return ServiceResult<WalletBalanceDto>.Failure("Wallet not found");

                var balanceDto = _mapper.Map<WalletBalanceDto>(wallet);
                return ServiceResult<WalletBalanceDto>.Success(balanceDto);
            }
            catch (Exception ex)
            {
                return ServiceResult<WalletBalanceDto>.Failure(
                    $"Error retrieving balance: {ex.Message}");
            }
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Validators\CreateMoneyRequestValidator.cs =====
using DigitalWallet.Application.DTOs.MoneyRequest;
using FluentValidation;

namespace DigitalWallet.Application.Validators
{
    public class CreateMoneyRequestValidator : AbstractValidator<CreateMoneyRequestDto>
    {
        public CreateMoneyRequestValidator()
        {
            RuleFor(x => x.ToUserPhoneOrEmail)
                .NotEmpty().WithMessage("Recipient phone or email is required");

            RuleFor(x => x.Amount)
                .GreaterThan(0).WithMessage("Amount must be greater than zero")
                .LessThanOrEqualTo(50000).WithMessage("Amount cannot exceed 50,000");

            RuleFor(x => x.CurrencyCode)
                .NotEmpty().WithMessage("Currency code is required")
                .Length(3).WithMessage("Currency code must be 3 characters");
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Validators\DepositRequestValidator.cs =====
using DigitalWallet.Application.DTOs.FakeBank;
using FluentValidation;

namespace DigitalWallet.Application.Validators
{
    public class DepositRequestValidator : AbstractValidator<DepositRequestDto>
    {
        public DepositRequestValidator()
        {
            RuleFor(x => x.UserId)
                .NotEmpty().WithMessage("User ID is required");

            RuleFor(x => x.Amount)
                .GreaterThan(0).WithMessage("Amount must be greater than zero")
                .LessThanOrEqualTo(100000).WithMessage("Amount cannot exceed 100,000");
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Validators\LoginRequestValidator.cs =====
using DigitalWallet.Application.DTOs.Auth;
using FluentValidation;

namespace DigitalWallet.Application.Validators
{
    public class LoginRequestValidator : AbstractValidator<LoginRequestDto>
    {
        public LoginRequestValidator()
        {
            RuleFor(x => x.EmailOrPhone)
                .NotEmpty().WithMessage("Email or phone number is required");

            RuleFor(x => x.Password)
                .NotEmpty().WithMessage("Password is required");
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Validators\PayBillRequestValidator.cs =====
using DigitalWallet.Application.DTOs.BillPayment;
using FluentValidation;

namespace DigitalWallet.Application.Validators
{
    public class PayBillRequestValidator : AbstractValidator<PayBillRequestDto>
    {
        public PayBillRequestValidator()
        {
            RuleFor(x => x.WalletId)
                .NotEmpty().WithMessage("Wallet ID is required");

            RuleFor(x => x.BillerId)
                .NotEmpty().WithMessage("Biller ID is required");

            RuleFor(x => x.Amount)
                .GreaterThan(0).WithMessage("Amount must be greater than zero")
                .LessThanOrEqualTo(100000).WithMessage("Amount cannot exceed 100,000");

            RuleFor(x => x.OtpCode)
                .NotEmpty().WithMessage("OTP code is required")
                .Length(6).WithMessage("OTP code must be 6 digits");
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Validators\RegisterRequestValidator.cs =====
using DigitalWallet.Application.DTOs.Auth;
using FluentValidation;

namespace DigitalWallet.Application.Validators
{
    public class RegisterRequestValidator : AbstractValidator<RegisterRequestDto>
    {
        public RegisterRequestValidator()
        {
            RuleFor(x => x.FullName)
                .NotEmpty().WithMessage("Full name is required")
                .MinimumLength(3).WithMessage("Full name must be at least 3 characters")
                .MaximumLength(100).WithMessage("Full name cannot exceed 100 characters");

            RuleFor(x => x.Email)
                .NotEmpty().WithMessage("Email is required")
                .EmailAddress().WithMessage("Invalid email format");

            RuleFor(x => x.PhoneNumber)
                .NotEmpty().WithMessage("Phone number is required")
                .Matches(@"^01[0-2,5]{1}[0-9]{8}$")
                .WithMessage("Invalid Egyptian phone number format (01XXXXXXXXX)");

            RuleFor(x => x.Password)
                .NotEmpty().WithMessage("Password is required")
                .MinimumLength(8).WithMessage("Password must be at least 8 characters")
                .Matches(@"[A-Z]").WithMessage("Password must contain at least one uppercase letter")
                .Matches(@"[a-z]").WithMessage("Password must contain at least one lowercase letter")
                .Matches(@"[0-9]").WithMessage("Password must contain at least one number");

            RuleFor(x => x.ConfirmPassword)
                .NotEmpty().WithMessage("Confirm password is required")
                .Equal(x => x.Password).WithMessage("Passwords do not match");
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Validators\SendMoneyRequestValidator.cs =====
using DigitalWallet.Application.DTOs.Transfer;
using FluentValidation;

namespace DigitalWallet.Application.Validators
{
    public class SendMoneyRequestValidator : AbstractValidator<SendMoneyRequestDto>
    {
        public SendMoneyRequestValidator()
        {
            RuleFor(x => x.SenderWalletId)
                .NotEmpty().WithMessage("Sender wallet ID is required");

            RuleFor(x => x.ReceiverPhoneOrEmail)
                .NotEmpty().WithMessage("Receiver phone or email is required");

            RuleFor(x => x.Amount)
                .GreaterThan(0).WithMessage("Amount must be greater than zero")
                .LessThanOrEqualTo(50000).WithMessage("Amount cannot exceed 50,000");

            RuleFor(x => x.OtpCode)
                .NotEmpty().WithMessage("OTP code is required")
                .Length(6).WithMessage("OTP code must be 6 digits");

            RuleFor(x => x.Description)
                .MaximumLength(255).WithMessage("Description cannot exceed 255 characters");
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\Validators\WithdrawRequestValidator.cs =====
using DigitalWallet.Application.DTOs.FakeBank;
using FluentValidation;

namespace DigitalWallet.Application.Validators
{
    public class WithdrawRequestValidator : AbstractValidator<WithdrawRequestDto>
    {
        public WithdrawRequestValidator()
        {
            RuleFor(x => x.UserId)
                .NotEmpty().WithMessage("User ID is required");

            RuleFor(x => x.Amount)
                .GreaterThan(0).WithMessage("Amount must be greater than zero")
                .LessThanOrEqualTo(100000).WithMessage("Amount cannot exceed 100,000");
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Application\DigitalWallet.Application.csproj =====
<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<TargetFramework>net8.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AutoMapper" Version="12.0.1" />
		<PackageReference Include="FluentValidation" Version="11.11.0" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\DigitalWallet.Domain\DigitalWallet.Domain.csproj" />
	</ItemGroup>
</Project>
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Common\BaseEntity.cs =====
namespace DigitalWallet.Domain.Common
{
    public abstract class BaseEntity
    {
        public Guid Id { get; set; }
        public DateTime CreatedAt { get; set; }

        protected BaseEntity()
        {
            Id = Guid.NewGuid();
            CreatedAt = DateTime.UtcNow;
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\AdminActionsLog.cs =====
using DigitalWallet.Domain.Common;

namespace DigitalWallet.Domain.Entities
{
    public class AdminActionsLog : BaseEntity
    {
        public Guid AdminId { get; set; }
        public string Action { get; set; } = string.Empty;
        public Guid? TargetUserId { get; set; }
        public string? Data { get; set; } // JSON

        // Navigation Properties
        public AdminUser Admin { get; set; } = null!;
        public User? TargetUser { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\AdminUser.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class AdminUser : BaseEntity
    {
        public string FullName { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;
        public string PasswordHash { get; set; } = string.Empty;
        public AdminRole Role { get; set; }

        // Navigation Property
        public ICollection<AdminActionsLog> Actions { get; set; } = new List<AdminActionsLog>();
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\Biller.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class Biller : BaseEntity
    {
        public string Name { get; set; } = string.Empty;
        public BillCategory Category { get; set; }
        public bool IsActive { get; set; }

        // Navigation Property
        public ICollection<BillPayment> BillPayments { get; set; } = new List<BillPayment>();
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\BillPayment.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class BillPayment : BaseEntity
    {
        public Guid UserId { get; set; }
        public Guid WalletId { get; set; }
        public Guid BillerId { get; set; }
        public decimal Amount { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
        public TransactionStatus Status { get; set; }
        public string? ReceiptPath { get; set; }

        // Navigation Properties
        public User User { get; set; } = null!;
        public Wallet Wallet { get; set; } = null!;
        public Biller Biller { get; set; } = null!;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\FakeBankAccount.cs =====
using DigitalWallet.Domain.Common;

namespace DigitalWallet.Domain.Entities
{
    public class FakeBankAccount : BaseEntity
    {
        public Guid UserId { get; set; }
        public string AccountNumber { get; set; } = string.Empty;
        public decimal Balance { get; set; }

        // Navigation Property
        public User User { get; set; } = null!;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\FakeBankTransaction.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class FakeBankTransaction : BaseEntity
    {
        public Guid UserId { get; set; }
        public decimal Amount { get; set; }
        public string Type { get; set; } = string.Empty; // "deposit" or "withdraw"
        public TransactionStatus Status { get; set; }
        public int DelaySeconds { get; set; }

        // Navigation Property
        public User User { get; set; } = null!;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\FraudLog.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class FraudLog : BaseEntity
    {
        public Guid UserId { get; set; }
        public FraudType Type { get; set; }
        public string? Description { get; set; }

        // Navigation Property
        public User User { get; set; } = null!;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\MoneyRequest.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class MoneyRequest : BaseEntity
    {
        public Guid FromUserId { get; set; }
        public Guid ToUserId { get; set; }
        public decimal Amount { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
        public MoneyRequestStatus Status { get; set; }

        // Navigation Properties
        public User FromUser { get; set; } = null!;
        public User ToUser { get; set; } = null!;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\Notification.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class Notification : BaseEntity
    {
        public Guid UserId { get; set; }
        public string Title { get; set; } = string.Empty;
        public string Body { get; set; } = string.Empty;
        public NotificationType Type { get; set; }
        public bool IsRead { get; set; }

        // Navigation Property
        public User User { get; set; } = null!;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\OtpCode.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class OtpCode : BaseEntity
    {
        public Guid UserId { get; set; }
        public string Code { get; set; } = string.Empty;
        public OtpType Type { get; set; }
        public DateTime ExpiresAt { get; set; }
        public bool IsUsed { get; set; }

        // Navigation Property
        public User User { get; set; } = null!;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\Refund.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class Refund : BaseEntity
    {
        public Guid OriginalTransactionId { get; set; }
        public decimal Amount { get; set; }
        public string? Reason { get; set; }
        public TransactionStatus Status { get; set; }

        // Navigation Property
        public Transaction OriginalTransaction { get; set; } = null!;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\RewardWallet.cs =====
using DigitalWallet.Domain.Common;

namespace DigitalWallet.Domain.Entities
{
    public class RewardWallet : BaseEntity
    {
        public Guid UserId { get; set; }
        public decimal Balance { get; set; }
        public string CurrencyCode { get; set; } = "EGP";

        // Navigation Property
        public User User { get; set; } = null!;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\Transaction.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class Transaction : BaseEntity
    {
        public Guid WalletId { get; set; }
        public TransactionType Type { get; set; }
        public decimal Amount { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
        public TransactionStatus Status { get; set; }
        public string? Description { get; set; }
        public string? Reference { get; set; }

        // Navigation Properties
        public Wallet Wallet { get; set; } = null!;
        public Refund? Refund { get; set; }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\Transfer.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class Transfer : BaseEntity
    {
        public Guid SenderWalletId { get; set; }
        public Guid ReceiverWalletId { get; set; }
        public decimal Amount { get; set; }
        public string CurrencyCode { get; set; } = string.Empty;
        public TransactionStatus Status { get; set; }

        // Navigation Properties
        public Wallet SenderWallet { get; set; } = null!;
        public Wallet ReceiverWallet { get; set; } = null!;
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\User.cs =====
using DigitalWallet.Domain.Common;
using DigitalWallet.Domain.Enums;

namespace DigitalWallet.Domain.Entities
{
    public class User : BaseEntity
    {
        public string FullName { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;
        public string PhoneNumber { get; set; } = string.Empty;
        public string PasswordHash { get; set; } = string.Empty;
        public string Salt { get; set; } = string.Empty;
        public KycLevel KycLevel { get; set; }
        public UserStatus Status { get; set; }
        public DateTime? LastLoginAt { get; set; }

        // Navigation Properties
        public ICollection<OtpCode> OtpCodes { get; set; } = new List<OtpCode>();
        public ICollection<Wallet> Wallets { get; set; } = new List<Wallet>();
        public RewardWallet? RewardWallet { get; set; }
        public FakeBankAccount? FakeBankAccount { get; set; }
        public ICollection<FakeBankTransaction> FakeBankTransactions { get; set; } = new List<FakeBankTransaction>();
        public ICollection<BillPayment> BillPayments { get; set; } = new List<BillPayment>();
        public ICollection<Notification> Notifications { get; set; } = new List<Notification>();
        public ICollection<FraudLog> FraudLogs { get; set; } = new List<FraudLog>();
        public ICollection<MoneyRequest> SentRequests { get; set; } = new List<MoneyRequest>();
        public ICollection<MoneyRequest> ReceivedRequests { get; set; } = new List<MoneyRequest>();
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Entities\Wallet.cs =====
using System.Transactions;
using DigitalWallet.Domain.Common;

namespace DigitalWallet.Domain.Entities
{
    public class Wallet : BaseEntity
    {
        public Guid UserId { get; set; }
        public string CurrencyCode { get; set; } = "EGP";
        public decimal Balance { get; set; }
        public decimal DailyLimit { get; set; } = 5000;
        public decimal MonthlyLimit { get; set; } = 20000;

        // Navigation Properties
        public User User { get; set; } = null!;
        public ICollection<Transaction> Transactions { get; set; } = new List<Transaction>();
        public ICollection<Transfer> SentTransfers { get; set; } = new List<Transfer>();
        public ICollection<Transfer> ReceivedTransfers { get; set; } = new List<Transfer>();
        public ICollection<BillPayment> BillPayments { get; set; } = new List<BillPayment>();
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Enums\AdminRole.cs =====
namespace DigitalWallet.Domain.Enums
{
    public enum AdminRole
    {
        SuperAdmin = 1,
        Support = 2,
        Auditor = 3
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Enums\BillCategory.cs =====
namespace DigitalWallet.Domain.Enums
{
    public enum BillCategory
    {
        Electricity = 1,
        Water = 2,
        Internet = 3,
        Subscription = 4,
        Other = 5
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Enums\FraudType.cs =====
namespace DigitalWallet.Domain.Enums
{
    public enum FraudType
    {
        SuspiciousTransfer = 1,
        TooManyAttempts = 2,
        LoginWarning = 3,
        UnusualAmount = 4
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Enums\KycLevel.cs =====
namespace DigitalWallet.Domain.Enums
{
    public enum KycLevel
    {
        Basic = 1,
        Verified = 2,
        Premium = 3
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Enums\MoneyRequestStatus.cs =====
namespace DigitalWallet.Domain.Enums
{
    public enum MoneyRequestStatus
    {
        Pending = 1,
        Accepted = 2,
        Rejected = 3,
        Expired = 4
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Enums\NotificationType.cs =====
namespace DigitalWallet.Domain.Enums
{
    public enum NotificationType
    {
        Transaction = 1,
        Security = 2,
        System = 3,
        Promotion = 4
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Enums\OtpType.cs =====
namespace DigitalWallet.Domain.Enums
{
    public enum OtpType
    {
        Login = 1,
        Transfer = 2
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Enums\TransactionStatus.cs =====
namespace DigitalWallet.Domain.Enums
{
    public enum TransactionStatus
    {
        Pending = 1,
        Success = 2,
        Failed = 3
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Enums\TransactionType.cs =====
namespace DigitalWallet.Domain.Enums
{
    public enum TransactionType
    {
        Transfer = 1,
        Bill = 2,
        Deposit = 3,
        Withdraw = 4,
        Refund = 5
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Enums\UserStatus.cs =====
namespace DigitalWallet.Domain.Enums
{
    public enum UserStatus
    {
        Active = 1,
        Suspended = 2,
        Banned = 3
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Exceptions\DomainException.cs =====
namespace DigitalWallet.Domain.Exceptions
{
    public class DomainException : Exception
    {
        public DomainException(string message) : base(message)
        {
        }

        public DomainException(string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Exceptions\InsufficientBalanceException.cs =====
namespace DigitalWallet.Domain.Exceptions
{
    public class InsufficientBalanceException : DomainException
    {
        public InsufficientBalanceException()
            : base("Insufficient balance in wallet")
        {
        }

        public InsufficientBalanceException(decimal balance, decimal required)
            : base($"Insufficient balance. Available: {balance}, Required: {required}")
        {
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Exceptions\InvalidOtpException.cs =====
namespace DigitalWallet.Domain.Exceptions
{
    public class InvalidOtpException : DomainException
    {
        public InvalidOtpException()
            : base("Invalid or expired OTP code")
        {
        }

        public InvalidOtpException(string message) : base(message)
        {
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Exceptions\InvalidTransferException.cs =====
namespace DigitalWallet.Domain.Exceptions
{
    public class InvalidTransferException : DomainException
    {
        public InvalidTransferException(string message) : base(message)
        {
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Exceptions\UserNotFoundException.cs =====
namespace DigitalWallet.Domain.Exceptions
{
    public class UserNotFoundException : DomainException
    {
        public UserNotFoundException()
            : base("User not found")
        {
        }

        public UserNotFoundException(Guid userId)
            : base($"User with ID {userId} not found")
        {
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\Exceptions\WalletLimitExceededException.cs =====
namespace DigitalWallet.Domain.Exceptions
{
    public class WalletLimitExceededException : DomainException
    {
        public WalletLimitExceededException(string limitType)
            : base($"{limitType} limit exceeded")
        {
        }

        public WalletLimitExceededException(decimal limit, decimal attempted)
            : base($"Limit exceeded. Limit: {limit}, Attempted: {attempted}")
        {
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Domain\DigitalWallet.Domain.csproj =====
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Infrastructure\Data\Configurations\AdminActionsLogConfiguration.cs =====
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Infrastructure.Data.Configurations
{
    public class AdminActionsLogConfiguration : IEntityTypeConfiguration<AdminActionsLog>
    {
        public void Configure(EntityTypeBuilder<AdminActionsLog> builder)
        {
            builder.ToTable("AdminActionsLogs");

            builder.HasKey(a => a.Id);

            builder.Property(a => a.AdminId)
                .IsRequired();

            builder.Property(a => a.Action)
                .IsRequired()
                .HasMaxLength(255);

            builder.Property(a => a.TargetUserId)
                .IsRequired(false);

            builder.Property(a => a.Data)
                .HasColumnType("nvarchar(max)");

            builder.Property(a => a.CreatedAt)
                .IsRequired();

            builder.HasIndex(a => a.AdminId);
            builder.HasIndex(a => a.TargetUserId);

            // Relationship with User (optional)
            builder.HasOne(a => a.TargetUser)
                .WithMany()
                .HasForeignKey(a => a.TargetUserId)
                .OnDelete(DeleteBehavior.SetNull);
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Infrastructure\Data\Configurations\AdminUserConfiguration.cs =====
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Infrastructure.Data.Configurations
{
    public class AdminUserConfiguration : IEntityTypeConfiguration<AdminUser>
    {
        public void Configure(EntityTypeBuilder<AdminUser> builder)
        {
            builder.ToTable("AdminUsers");

            builder.HasKey(a => a.Id);

            builder.Property(a => a.FullName)
                .IsRequired()
                .HasMaxLength(150);

            builder.Property(a => a.Email)
                .IsRequired()
                .HasMaxLength(150);

            builder.HasIndex(a => a.Email)
                .IsUnique();

            builder.Property(a => a.PasswordHash)
                .IsRequired()
                .HasMaxLength(255);

            builder.Property(a => a.Role)
                .IsRequired()
                .HasConversion<string>()
                .HasMaxLength(30)
                .HasDefaultValue("Support");

            builder.Property(a => a.CreatedAt)
                .IsRequired();

            // Relationships
            builder.HasMany(a => a.Actions)
                .WithOne(l => l.Admin)
                .HasForeignKey(l => l.AdminId)
                .OnDelete(DeleteBehavior.Cascade);
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Infrastructure\Data\Configurations\BillerConfiguration.cs =====
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using DigitalWallet.Domain.Entities;

namespace DigitalWallet.Infrastructure.Data.Configurations
{
    public class BillerConfiguration : IEntityTypeConfiguration<Biller>
    {
        public void Configure(EntityTypeBuilder<Biller> builder)
        {
            builder.ToTable("Billers");

            builder.HasKey(b => b.Id);

            builder.Property(b => b.Name)
                .IsRequired()
                .HasMaxLength(150);

            builder.Property(b => b.Category)
                .IsRequired()
                .HasConversion<string>()
                .HasMaxLength(50);

            builder.Property(b => b.IsActive)
                .IsRequired()
                .HasDefaultValue(true);

            builder.Property(b => b.CreatedAt)
                .IsRequired();

            // Relationships
            builder.HasMany(b => b.BillPayments)
                .WithOne(p => p.Biller)
                .HasForeignKey(p => p.BillerId)
                .OnDelete(DeleteBehavior.Restrict);
        }
    }
}
===== C:\Users\SoftLaptop\Desktop\DigitalWallet-Graduation-Project-\DigitalWallet.Infrastructure\Data\Configurations\BillPaymentConfiguration.cs =====
